- [1. 引言](#1-引言)
- [2. RFC 3489 的演进](#2-rfc-3489-的演进)
- [3. 运行概述](#3-运行概述)
- [4. 术语](#4-术语)
- [5. 定义](#5-定义)
- [6. STUN 消息结构](#6-stun-消息结构)
  - [STUN Message Type](#stun-message-type)
  - [Magic Cookie](#magic-cookie)
  - [Transaction ID](#transaction-id)
  - [Message Length](#message-length)
- [7. 基本协议流程](#7-基本协议流程)
  - [7.1. 构造请求或指示消息](#71-构造请求或指示消息)
  - [7.2. 发送请求或指示消息](#72-发送请求或指示消息)
    - [7.2.1. 通过 UDP 发送](#721-通过-udp-发送)
    - [7.2.2. 通过 TCP 或 TLS-over-TCP 发送](#722-通过-tcp-或-tls-over-tcp-发送)
  - [7.3 接收 STUN 消息](#73-接收-stun-消息)
    - [7.3.1 处理请求](#731-处理请求)
      - [7.3.1.1 构建成功或错误响应](#7311-构建成功或错误响应)
      - [7.3.1.2 发送成功或错误响应](#7312-发送成功或错误响应)
    - [7.3.2 处理指示（Indication）](#732-处理指示indication)
    - [7.3.3 处理成功响应](#733-处理成功响应)
    - [7.3.4 处理错误响应](#734-处理错误响应)
- [8. FINGERPRINT 机制](#8-fingerprint-机制)
- [9. 基于 DNS 的服务器发现](#9-基于-dns-的服务器发现)
- [10. 身份验证和消息完整性机制](#10-身份验证和消息完整性机制)
  - [10.1. 短期凭证机制](#101-短期凭证机制)
    - [10.1.1. 构建请求或指示](#1011-构建请求或指示)
    - [10.1.2. 接收请求或指示](#1012-接收请求或指示)
    - [10.1.3. 接收响应](#1013-接收响应)
  - [10.2.  长期凭证机制](#102--长期凭证机制)
    - [10.2.1.  构造请求](#1021--构造请求)
    - [10.2.1.1.  第一个请求](#10211--第一个请求)
    - [10.2.1.2.  后续请求](#10212--后续请求)
    - [10.2.2.  接收请求](#1022--接收请求)
    - [10.2.3.  接收响应](#1023--接收响应)
- [11. ALTERNATE-SERVER 机制](#11-alternate-server-机制)
- [12. 与 RFC 3489 向后兼容性](#12-与-rfc-3489-向后兼容性)
  - [12.1 客户端处理的更改](#121-客户端处理的更改)
  - [12.2 服务器处理的更改](#122-服务器处理的更改)
  - [13. 基本服务器行为](#13-基本服务器行为)
    - [核心要求](#核心要求)
    - [部署建议](#部署建议)
- [14.  STUN 用法](#14--stun-用法)
- [15. STUN 属性](#15-stun-属性)
  - [15.1. MAPPED-ADDRESS](#151-mapped-address)
  - [15.2. XOR-MAPPED-ADDRESS](#152-xor-mapped-address)
  - [15.3.  USERNAME](#153--username)
  - [15.4.  MESSAGE-INTEGRITY](#154--message-integrity)
  - [15.5.  FINGERPRINT](#155--fingerprint)
  - [15.6.  ERROR-CODE](#156--error-code)
  - [15.7.  REALM](#157--realm)
  - [15.8.  NONCE](#158--nonce)
  - [15.9.  UNKNOWN-ATTRIBUTES](#159--unknown-attributes)
  - [15.10.  SOFTWARE](#1510--software)
  - [15.11.  ALTERNATE-SERVER](#1511--alternate-server)
- [16.  安全考虑](#16--安全考虑)
  - [16.1.  针对协议的攻击](#161--针对协议的攻击)
    - [16.1.1.  外部攻击](#1611--外部攻击)
    - [16.1.2.  内部攻击](#1612--内部攻击)
  - [16.2.  影响 STUN 用法的攻击](#162--影响-stun-用法的攻击)
    - [16.2.1 攻击 I：对目标的分布式拒绝服务（DDoS）](#1621-攻击-i对目标的分布式拒绝服务ddos)
    - [16.2.2 攻击 II：静默客户端](#1622-攻击-ii静默客户端)
    - [16.2.3 攻击 III：冒充客户端身份](#1623-攻击-iii冒充客户端身份)
    - [16.2.4 攻击 IV：窃听](#1624-攻击-iv窃听)
  - [16.3.  哈希算法灵活性计划](#163--哈希算法灵活性计划)
- [17.  IAB 考虑事项](#17--iab-考虑事项)
- [18.  IANA 考虑事项](#18--iana-考虑事项)
  - [18.1.  STUN 方法注册表](#181--stun-方法注册表)
  - [18.2.  STUN 属性注册表](#182--stun-属性注册表)
  - [18.3.  STUN 错误代码注册表](#183--stun-错误代码注册表)
  - [18.4.  STUN UDP 和 TCP 端口号](#184--stun-udp-和-tcp-端口号)
## 1. 引言

本规范定义的协议 **STUN（会话穿越工具，Session Traversal Utilities for NAT）** 是一种用于处理 NAT（网络地址转换）问题的工具。它提供了一种方式，使终端设备能够确定 NAT 为其分配的 **IP 地址和端口**，这些地址和端口对应于其私有 IP 地址和端口。此外，该协议还提供了一种机制，使终端设备能够维持 NAT 绑定的存活时间。通过一些扩展，该协议还可以用于 **两个终端之间的连通性检查** [MMUSIC-ICE]，或者用于在两个终端之间 **中继数据包** [BEHAVE-TURN]。

作为一种工具，本规范定义了一种 **可扩展的数据包格式**，支持 **多种传输协议**，并提供了 **两种认证方式**。

STUN 旨在用作 **NAT 穿越解决方案** 的一部分，而不是完整的 NAT 穿越解决方案。这些解决方案被称为 **STUN 用法（STUN usages）**。每种 STUN 用法都描述了如何利用 STUN 实现 NAT 穿越，例如何时发送 STUN 消息、应包含哪些可选属性、使用哪种服务器以及采用何种认证机制。例如，**ICE（交互式连通性建立，Interactive Connectivity Establishment）** [MMUSIC-ICE] 是 STUN 的一种用法，而 **SIP Outbound** [SIP-OUTBOUND] 也是 STUN 的一种用法。在某些情况下，STUN 用法可能需要 STUN 协议的扩展，例如增加新的 **方法（methods）**、**属性（attributes）** 或 **错误响应代码（error response codes）**。关于 STUN 用法的更多信息，请参考 **第 14 章**。



## 2. RFC 3489 的演进  

STUN 最早在 **RFC 3489** [RFC3489] 中定义，该规范（有时称为 **经典 STUN**）将 STUN 视为 **完整的 NAT 穿越解决方案**。在该方案中，客户端可以：  

- 发现自己是否位于 NAT 之后  
- 确定其 **NAT 类型**  
- 获取其在 NAT 公网侧的 **IP 地址和端口**  
- 在某些协议（例如 SIP）中使用该 **公网地址和端口**  

然而，自 RFC 3489 发布以来的实践表明，经典 STUN **并不足以作为可部署的 NAT 穿越解决方案**。通过经典 STUN 获取的地址和端口 **可能** 可用于与对等方通信，也 **可能** 无法使用，而经典 STUN **无法判断** 它是否可用，也无法在不可用时提供补救措施。此外，经典 STUN 归类 NAT 类型的方法也存在缺陷，许多 NAT 设备并不符合 RFC 3489 定义的分类。  

经典 STUN 还存在 **安全漏洞**，即 **在某些特定网络拓扑下，攻击者可能向客户端提供错误的映射地址**，而这一问题无法通过加密手段解决。尽管这一问题在本规范中仍然存在，但 STUN 现在作为 **完整 NAT 穿越方案的一部分** 进行使用，从而 **降低了安全风险**。  

因此，本规范 **废弃** 了 RFC 3489，并 **重新定义** 了 STUN，明确其作为 **NAT 穿越工具** 而非完整的解决方案。例如，**ICE** [MMUSIC-ICE] 是 **基于 STUN 的完整 NAT 穿越解决方案**，适用于 **基于 Offer/Answer（提议/应答）模型的协议**（例如 SIP）。**SIP Outbound** [SIP-OUTBOUND] 也是一种完整的 **SIP 信令 NAT 穿越解决方案**，它以不同方式使用 STUN。虽然某些协议仍可能单独使用 STUN 进行 NAT 穿越，但本规范 **不鼓励** 这样做。  

本规范在协议设计上相较于经典 STUN **变化不大**，但做了一些关键调整，包括：  

- **新增 TCP 作为传输协议**（RFC 3489 仅支持 UDP）  
- **增强了协议的可扩展性**  
- **引入“魔法 Cookie”**（magic cookie）机制，便于与其他应用协议复用  
- **新增 XOR-MAPPED-ADDRESS 属性**（替代 MAPPED-ADDRESS，以提高安全性）  

由于 STUN 的 **作用范围** 发生了变化，本规范 **更改了 STUN 的全称**，从 **“简单的 UDP NAT 穿越（Simple Traversal of UDP through NAT）”** 改为 **“会话穿越工具（Session Traversal Utilities for NAT）”**，但缩写仍然保持 **STUN**。



## 3. 运行概述  

本节仅作 **描述性说明**。  

**STUN 可能的网络架构**  

```

                               /-----\
                             // STUN  \\
                            |   Server  |
                             \\       //
                               \-----/




                          +--------------+             Public Internet
          ................|     NAT 2    |.......................
                          +--------------+



                          +--------------+             Private NET 2
          ................|     NAT 1    |.......................
                          +--------------+




                              /-----\
                            //  STUN \\
                           |   Client  |
                            \\       //               Private NET 1
                              \-----/
```

在 **典型 STUN 体系结构**（如上图所示）中：  

- **STUN 客户端** 位于私有网络（私网 1）  
- **NAT 设备（NAT 1 和 NAT 2）** 连接不同的私网或公网  
- **STUN 服务器** 位于公网  

STUN 是一种 **客户端-服务器协议**，支持 **两种事务类型**：  

1. **请求/响应事务（request/response transaction）**——客户端发送请求，服务器返回响应。  
2. **指示事务（indication transaction）**——仅包含一个单向指示消息，无需响应。  

所有 STUN 消息都带有 **事务 ID（transaction ID）**，用于匹配请求与响应。STUN 服务器通过 **XOR-MAPPED-ADDRESS 属性**，将客户端的公网地址回传给客户端，从而使客户端 **得知 NAT 分配的公网 IP 和端口**。  



## 4. 术语
本文件使用的关键字 **MUST、MUST NOT、SHALL、SHOULD、MAY** 等，按照 RFC 2119[RFC2119] 进行解释，以指示 STUN 实现的要求级别。  


## 5. 定义  

- **STUN 代理（STUN Agent）**：支持 STUN 协议的实体，包括 STUN 客户端和 STUN 服务器。  
- **STUN 客户端（STUN Client）**：发送 STUN 请求和指示的实体。  
- **STUN 服务器（STUN Server）**：接收 STUN 请求并发送响应的实体。  
- **传输地址（Transport Address）**：IP 地址与端口的组合（如 UDP 或 TCP 端口）。  
- **映射地址（Mapped Address）**：即 NAT 为客户端分配的公网 IP 地址和端口，即 `XOR-MAPPED-ADDRESS`。  



## 6. STUN 消息结构 
 

STUN 消息采用二进制编码，使用网络字节序（即最高有效字节优先，通常称为 **大端字节序**）。其传输顺序在 RFC 791 [RFC0791] 的 附录 B 中有详细描述。除非特别说明，数值常量均使用十进制（base 10）。  

所有 STUN 消息 **必须以 20 字节的固定头部** 开头，随后可能包含 **零个或多个属性（Attributes）**。STUN 头部包含以下字段：
- STUN 消息类型（STUN Message Type）
- 魔法 Cookie（Magic Cookie）
- 事务 ID（Transaction ID）
- 消息长度（Message Length）

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |0 0|     STUN Message Type     |         Message Length        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         Magic Cookie                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                     Transaction ID (96 bits)                  |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图 2：STUN 消息头部格式**  

每个 STUN 消息的 **最高两位必须为 0**。这可以在STUN 复用端口时用于区分 STUN 数据包和其他协议数据包。  

### STUN Message Type
消息类型（STUN Message Type）字段定义了 STUN 消息的类别（request, success response, failure response, indication）以及 message method(the primary function)。  

**尽管 STUN 具有四种消息类别，但在协议层面上，STUN 仅支持两种事务类型**：  

1. **请求/响应事务（request/response transactions）**，包括请求消息和 响应消息。  
2. **指示事务（indication transactions）**，仅包含 **单个指示消息，不会收到响应。**  

响应类别被划分为错误响应和成功响应，以便快速处理 STUN 消息。  

```
                        0                 1
                        2  3  4 5 6 7 8 9 0 1 2 3 4 5

                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                       |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                       |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图 3：STUN 消息类型（STUN Message Type）字段格式**  

在消息类型字段中，位的排列方式如下：
- M11-M0：12 位，表示 STUN 消息方法。  
- C1、C0：2 位，指示消息类别：
  - `00` = **请求（Request）**
  - `01` = **指示（Indication）**
  - `10` = **成功响应（Success Response）**
  - `11` = **错误响应（Error Response）**  

例如，Binding 请求：
- 类别 `00`（请求），方法 `000000000001`（Binding），编码值：`0x0001`。  

Binding 成功响应：
- 类别 `10`（成功响应），方法 `000000000001`（Binding），编码值：`0x0101`。  

>**注意**：这种编码方式来源于RFC 3489，当时并未考虑指示、成功响应和错误响应需要单独编码。 

### Magic Cookie

**魔法 Cookie 字段必须包含固定值0x2112A442（网络字节序）。**
 
在 RFC 3489 中，该字段曾是事务 ID 的一部分。将魔法 Cookie 置于此位置， **可以帮助服务器检测客户端是否支持本规范新增的属性，并帮助区分 STUN 数据包和其他协议数据包（当 STUN 与其他协议复用端口时）。**  

### Transaction ID

**事务 ID 是一个96 位（12 字节）的唯一标识符，用于唯一标识 STUN 事务， 生成规则如下：**

- 请求/响应事务：
  - 请求（Request）由 STUN 客户端生成事务 ID。  
  - 响应（Response） 由 STUN 服务器回显相同事务 ID。  
- 指示事务：
  - 事务 ID 由 发送指示消息的代理生成。  

事务 ID 主要用于 **将请求与响应关联，同时也可以降低某些攻击的风险**。服务器使用事务 ID 作为唯一键，以区分不同客户端的事务。  

事务 ID 必须在 `0 ... 2^96-1` 的范围内均匀随机选择，并且应采用加密安全的随机数。  

**相同请求的重新发送将重用相同的事务 ID，但客户端必须为新事务选择新的事务 ID**，除非新请求与前一个请求完全相同并从相同的传输地址发送到相同的 IP 地址。成功和错误响应必须携带与其对应请求相同的事务 ID。

当一个代理既作为 STUN 服务器，又作为 STUN 客户端（在同一端口上）时，该代理 **发送的请求的事务 ID与 接收的请求的事务 ID 无任何关系。**  

### Message Length

消息长度 **必须包含消息的字节大小（不包括 20 字节的 STUN 头部）**。  

由于 **所有 STUN 属性都填充为 4 字节的倍数**，因此消息长度字段的最后 2 位始终为 0，这提供了一种额外的方法来区分 STUN 数据包与其他协议数据包。  

 **在 STUN 消息固定头部之后，可能会有零个或多个属性（Attributes）**。  每个 STUN 属性都采用TLV（Type-Length-Value）格式，有关 STUN属性格式的详细信息，请参阅[第 15 节](#15-stun-属性)。




## 7. 基本协议流程  

本节定义了 STUN 协议的基本流程，包括消息的构造、发送方式以及接收后的处理方式。本节还详细说明了 **Binding 方法** 的处理过程。本规范的其他部分描述了一些 **可选流程**，STUN 用法（usage）可以在特定情况下选择使用。其他文档可能会扩展 STUN，例如 **新增方法、属性或错误响应代码**。


### 7.1. 构造请求或指示消息  

在构造请求（Request）或指示（Indication）消息时，STUN 代理（STUN agent）必须遵循[第 6 节](#6-stun-消息结构)规定的 STUN 头部格式。此外：  

- 消息类别（Message Class）必须是 请求（Request）或 指示（Indication）。  
- 方法（Method）必须是 `Binding` 或其他 STUN 扩展方法。  

接着，代理需要添加方法或 STUN 用法指定的任何属性。例如，一些 STUN 用法可能要求代理使用认证机制（参见[第 10 节](#10-身份验证和消息完整性机制)）或 FINGERPRINT 属性（参见[第 8 节](#8-fingerprint-机制)）。  

如果代理发送的是请求（Request），它应该在请求中添加 SOFTWARE 属性。对于指示（Indication），代理可以选择是否包含 SOFTWARE 属性，具体取决于使用的方法。STUN 扩展文档应该讨论 SOFTWARE 属性在新指示消息中的适用性。  

对于不使用认证的 Binding 方法，除非 STUN 用法另有规定，否则不需要任何属性。  

 **所有通过 UDP 发送的 STUN 消息应该小于路径 MTU（Path MTU）（如果已知）。** 如果路径 MTU 未知，则消息长度应该小于：  

- **IPv4**：576 字节（根据 [RFC1122]），扣除 20 字节 IP 头部和 8 字节 UDP 头部 后，STUN 消息最大长度应为 **548 字节**。  
- **IPv6**：1280 字节（根据 [RFC2460]）。  

STUN 无法处理 **请求消息小于 MTU 但响应消息超过 MTU** 的情况。不过，预计这一限制 **不会对 STUN 造成影响**。  

MTU 限制是应该而非必须，是为了适应某些特殊情况，例如使用 STUN 进行 MTU 探测[BEHAVE-NAT]。但在其他应用场景中，**必须遵循 MTU 约束**。  



### 7.2. 发送请求或指示消息  

代理接下来发送 **请求（Request）** 或 **指示（Indication）**。本规范规定了 **UDP、TCP 和 TLS-over-TCP** 这三种传输方式，未来可能支持其他传输协议。  

STUN 用法必须指定：  
- **使用哪种传输协议**。  
- **代理如何确定接收方的 IP 地址和端口**。  

[第 9 节]() 描述了一种基于 DNS 的方法，可用于确定服务器的 IP 地址和端口，STUN 用法可以选择使用该方法。  

STUN 也可以与 **Anycast 地址** 一起使用，但仅限 **UDP 传输** 且 **不使用认证** 的场景。  

>在任何时候，客户端可以发送多个未完成的 STUN 请求到同一 STUN 服务器（即多个进行中的事务，每个具有不同的事务 ID）。除非另有速率限制（例如 ICE 连接检查或 TCP 传输的 STUN），否则**客户端应该（SHOULD）以RTO（重传超时）为间隔发送新事务，并限制自己最多同时拥有 10 个未完成的事务**。  



#### 7.2.1. 通过 UDP 发送 

当 STUN 运行在 UDP 之上时，STUN 消息可能会在网络中丢失。 **STUN请求/响应事务的可靠性由客户端自身通过请求重传来保证。**   

- **STUN 指示消息（Indications）不会重传，因此STUN 通过 UDP 发送的指示事务是不可靠的**。  

客户端应该按照以下策略重传请求：
- 初始重传时间间隔为 **RTO（Retransmission Timeout），之后每次重传间隔加倍**。  
- RTO 是往返时间（RTT）的估计值，其计算方式参考 [[RFC2988]]()，但有以下两个例外：  
  1. **初始 RTO 应可配置，且默认值不应小于 500 毫秒**（RFC 2988 推荐 3 秒）。  
     - 例外情况：如果使用了其他机制来确定 拥塞控制阈值（例如 ICE 的固定速率流）或在非互联网环境（如局域网）中，RTO 可设置为更低值。  
     - **对于固定线路接入的环境，推荐RTO = 500ms**。  
  2. **RTO 计算不应向上取整到秒级，应保持1 毫秒精度**。  

客户端在事务完成后应该缓存 RTO 值，并在下次向相同服务器（基于 IP 地址）发送请求时作为起始 RTO，该缓存值应在 10 分钟后作废。  

**重传规则**：
- 请求持续重传，直到：
  - 收到响应，或者  
  - 达到最大重传次数（Rc）。默认 Rc = 7（可配置）。  
- **如果发送最后一次请求后的 Rm × RTO 时间内仍未收到响应，客户端应该认为事务已失败**
  - 默认 Rm = 16（可配置）。  
- **收到硬 ICMP 错误（Hard ICMP Error）时，事务被视为失败 [RFC1122]** 

例如，假设 RTO = 500ms，请求的发送时间如下：  
```
0ms, 500ms, 1500ms, 3500ms, 7500ms, 15500ms, 31500ms
```
如果客户端在 **39500ms** 内未收到响应，则认为 **超时失败**。  



#### 7.2.2. 通过 TCP 或 TLS-over-TCP 发送  

对于 `TCP` 和 `TLS-over-TCP` 传输方式，客户端需要建立 TCP 连接到服务器。  

在某些 STUN 应用场景中，STUN 是 TCP 连接上唯一运行的协议。这种情况下，无需额外的帧协议（framing protocol）或解复用机制即可直接发送 STUN 消息。

而在其他应用场景或扩展中， **STUN 可能与其他数据协议复用 TCP 连接**。在这种情况下，STUN 必须运行在某种帧协议之上， **该协议由具体的 STUN 用法或扩展规定，以便 STUN 代理正确地提取完整的 STUN 消息和应用层消息**。  

运行于知名端口（well-known port）或通过第 9 节 DNS 流程发现的端口的 STUN 服务仅用于纯 STUN 通信 ，不会复用其他数据协议。因此，客户端连接到这些服务器时，不需要额外的帧协议。  

如果使用额外的帧协议，STUN 用法必须指定：
- **客户端如何确定使用该帧协议**
- **客户端应该连接到哪个端口**  

例如，在ICE 连接检查（ICE connectivity check）场景中，该信息是通过客户端和服务器之间的带外（out-of-band）协商确定的。  


**当 STUN 运行在 TLS-over-TCP 之上时**：
- **必须至少支持 `TLS_RSA_WITH_AES_128_CBC_SHA` 密码套件**，也可以选择支持其他加密套件。
- 客户端在接收 TLS 证书消息时，应验证证书并检查证书标识的站点：
  **若证书无效、被吊销或未标识合法实体，则客户端不得发送 STUN 消息或继续 STUN 事务。** 客户端必须验证服务端身份，具体遵循 RFC 2818 [[RFC2818] 第 3.1 节]()定义的身份验证流程。此流程假设客户端正在解引用（dereference）一个 URI。在本规范中，客户端将第 8.1 节使用的域名或 IP 地址视为解引用 URI 的主机部分。此外，客户端可配置为信任一组特定域名或 IP 地址；若收到的证书标识了其中某个域名或 IP 地址，则客户端认为服务端身份已验证。

若 STUN 通过 TLS-over-TCP 连接与其他协议复用，则强制加密套件和 TLS 处理流程由这些协议定义。

STUN 在 TCP 和 TLS-over-TCP 上的可靠性由 TCP 自身保障，STUN 协议层无需重传。然而，对于请求/响应事务，**若客户端在发送 SYN 建立连接后 Ti 秒内未收到响应，则认为事务超时。Ti 应可配置且默认值应为 39.5 秒。此值旨在使 TCP 和 UDP 的默认初始 RTO（重传超时）保持一致。**

此外，若客户端无法建立 TCP 连接，或**在接收响应前连接被重置或失败，则进行中的请求/响应事务视为失败。**

---

客户端可通过单个 TCP（或 TLS-over-TCP）连接发送多个事务，且无需等待前一个请求的响应即可发送新请求。客户端应保持连接开放，直至满足以下条件：
1. 无更多 STUN 请求或指示需通过该连接发送；
2. 无计划使用通过该连接 STUN 请求获取的资源（如映射地址 `MAPPED-ADDRESS`/`XOR-MAPPED-ADDRESS `或中继地址 `[BEHAVE-TURN]`）；
3. 若在该端口复用其他应用协议，则相关应用已结束使用；
4. 若将学习到的端口用于远程对端（如某些 TCP NAT 穿越技术要求），则已与该对端建立通信（例如 `[MMUSIC-ICE-TCP]`）。

服务器端 **应该保持 TCP 连接打开**，并 **等待客户端关闭连接**，除非**服务器检测到连接超时**（例如，客户端断开网络）。  

由于 **NAT 设备通常只在 TCP 连接保持打开时保持映射地址有效**，因此：
- **服务器不应主动关闭连接**，因为 **只有客户端知道何时不再需要映射地址**。  
- **如果服务器收到请求但尚未发送响应，服务器不得关闭连接**。  
- **服务器不得为了发送响应而主动建立回连（open a connection back to the client）**。  
- **服务器在负载过高时，应遵循最佳的连接管理策略**。  




### 7.3 接收 STUN 消息

本节规定 STUN 消息的处理流程。此处描述的处理规则适用于本规范定义的 STUN 消息；向后兼容的附加规则详见[第 12 节](#12-与-rfc-3489-向后兼容性)（可选实现，具体应用场景可决定是否采用）。首先执行与消息类别无关的通用处理操作，随后按消息类别进行特定处理（见后续子节）。

当 STUN 代理接收到 STUN 消息时，首先验证消息是否符合第 6 节的规则：  
1. **基础校验**：  
   - 检查消息前 2 位是否为 `0`；
   - 验证 Magic Cookie 字段值正确；
   - 确认消息长度合理；
   - 确认方法值（Method）为支持的方法；
   - 检查消息类别（Class）是否允许用于该方法。  
2. **事务匹配**：  
   - 若消息类别为“成功响应”（Success Response）或“错误响应”（Error Response），验证事务 ID 是否匹配当前进行中的事务。  
3. **扩展校验**：  
   - 若启用了 `FINGERPRINT` 扩展，检查是否存在该属性且值正确。  

若任何校验失败，则静默丢弃消息。当 STUN 与其他协议复用时，错误可能表明该消息并非 STUN 消息，此时代理应尝试将其解析为其他协议。

随后，代理根据应用场景指定的认证机制执行必要检查（参见第 10 节）。

完成认证后，代理检查消息中是否存在：  
- **未知属性**：  
  - 若为“可选理解属性”（comprehension-optional），必须忽略；  
  - 若为“必须理解属性”（comprehension-required），处理方式取决于消息类别（见下文）。  
- **已知但非预期属性**：建议忽略。

完成上述步骤后，根据消息类别进行进一步处理。



#### 7.3.1 处理请求

若请求包含一个或多个未知的“必须理解属性”，服务器应返回错误响应：  
- **错误码**：`420（Unknown Attribute）`  
- **附加属性**：包含未知属性的 `UNKNOWN-ATTRIBUTES` 属性。

随后，服务器按方法或应用场景要求执行额外检查。若所有检查通过，生成如下所述的成功响应。

**UDP 重传处理**：  
当通过 UDP 接收请求时，可能是首次请求或重传。服务器对重传的响应需满足以下条件：  
> 若客户端收到重传响应而非原始响应，客户端与服务器的状态应与仅收到重传响应或同时收到两者（客户端使用首个响应）的情况一致。  

**实现方式**：  
1. **状态保留法**（推荐但需权衡）：  
   - 服务器记录过去 **40 秒** 内通过 UDP 接收的事务 ID 及其对应响应。  
   - 适用于需保持状态的场景，但对未认证请求不适用。  
2. **幂等处理法**：  
   - 重新处理请求并生成相同响应，仅适用于幂等请求（即重复请求不会改变系统状态）。  
   - **绑定方法（Binding Method）** 视为幂等操作。  
   - 注意：极少数网络事件可能导致反射传输地址变更，使不同成功响应中的映射地址不同。  
   - **扩展要求**：未存储事务状态的服务器需在扩展中讨论重传影响。


##### 7.3.1.1 构建成功或错误响应

构建响应（成功或错误）时，服务器需遵循第 6 节的规则：  
- **响应方法**：与请求方法相同；  
- **消息类别**：需为“成功响应”（Success Response）或“错误响应”（Error Response）。  

**错误响应的特殊处理**：  
1. **错误码属性**：必须添加 `ERROR-CODE` 属性，包含上述处理流程中指定的错误码。  
2. **原因短语**：非固定内容，但应与错误码匹配。  
3. **附加属性**：  
   - 特定错误需添加额外属性（如错误码 `420（Unknown Attribute）` 必须包含 `UNKNOWN-ATTRIBUTES` 属性）；  
   - 认证错误可能触发附加属性（见第 10 节）；  
   - 扩展可定义新错误码及对应属性。  

**认证处理**：  
- 若请求已通过认证机制验证，响应中应添加相应认证属性（见第 10 节）。  

**通用属性要求**：  
- 按方法或应用场景添加必需属性；  
- 建议在消息中添加 `SOFTWARE` 属性。  

**绑定方法（Binding Method）的特殊规则**：  
- 若无应用场景特殊要求，无需额外检查；  
- 成功响应中必须添加 `XOR-MAPPED-ADDRESS` 属性，其值为请求消息的源传输地址：  
  - **UDP**：请求的源 IP 地址与源 UDP 端口；  
  - **TCP/TLS-over-TCP**：服务器感知的 TCP 连接的源 IP 地址与源 TCP 端口。  



##### 7.3.1.2 发送成功或错误响应

响应的发送方式与接收请求的传输层一致：  
1. **UDP 场景**：  
   - 响应目标地址 = 请求的源 IP 地址与端口；  
   - 响应源地址 = 请求的目标 IP 地址与端口。  
2. **TCP/TLS-over-TCP 场景**：通过同一 TCP 连接返回响应。  


#### 7.3.2 处理指示（Indication）

1. **未知属性检查**：若指示包含未知的“必须理解属性”（comprehension-required），则丢弃并终止处理。  
2. **应用层检查**：按方法或应用场景要求执行额外检查。若通过，处理该指示（无需生成响应）。  

**绑定方法的特殊规则**：  
- 若无特殊要求，仅接收指示即可刷新 NAT 中的“绑定”状态。  
- **UDP 重传机制**：指示无重传机制，发送代理无需处理重传。  


#### 7.3.3 处理成功响应

1. **未知属性检查**：若成功响应含未知的“必须理解属性”，则丢弃响应并视事务失败。  
2. **应用层检查**：按方法或应用场景要求执行额外检查。若通过，处理成功响应。  

**绑定方法的特殊规则**：  
- 检查响应中是否存在 `XOR-MAPPED-ADDRESS` 属性：  
  - **地址族不支持**：应忽略该属性；  
  - **地址族意外但支持**（如 IPv4 请求返回 IPv6 地址）：可选择接受并使用。  



#### 7.3.4 处理错误响应

1. **有效性检查**：  
   - 若错误响应含未知的“必须理解属性”或缺少 `ERROR-CODE` 属性，则视事务失败。  
2. **认证处理**：按认证机制要求执行处理（可能触发新事务尝试）。  

**默认处理规则**（按错误码分类）：  
- **300-399**：除非使用 `ALTERNATE-SERVER` 扩展（见第 11 节），否则视事务失败；  
- **400-499**：视事务失败。若为 `420（Unknown Attribute）`，响应中应含 `UNKNOWN-ATTRIBUTES` 属性；  
- **500-599**：可重发请求，但需限制重试次数；  
- **其他错误码**：直接视事务失败。  


## 8. FINGERPRINT 机制

本节描述 STUN 的可选扩展机制，用于在传输地址复用时区分 STUN 消息与其他协议数据包。该机制为可选实现，具体应用场景需明确其使用条件。需注意：指纹机制与 **RFC 3489** 不兼容，在需要向后兼容的环境中不可使用。

在某些应用场景中，STUN 消息与其他协议（例如实时传输协议 RTP）的数据包可能会复用同一传输地址，需先分离 STUN 消息以应用第 7 节的流程。虽然 STUN 头部已有三个固定字段（见第 6 节）用于识别，但某些场景下可能仍需额外校验。

**机制实现** ：
1. **发送端**：  
   代理在发送的消息中插入 `FINGERPRINT` 属性（属性格式及位置见第 [15.5 节](#155--fingerprint)）。
2. **接收端**：  
   代理在初步校验后（见第 [7.3 节](#73-接收-stun-消息)处理流程），进一步验证：  
   - 消息是否包含 `FINGERPRINT` 属性；  
   - 属性值是否正确。  
   此机制可有效排除其他协议数据包被误判为 STUN 消息的情况。




## 9. 基于 DNS 的服务器发现

本节描述了一种 STUN 的可选流程，该流程允许客户端利用 DNS 来确定服务器的 IP 地址和端口。每种 STUN 用法都必须说明是否以及何时使用该扩展。为了使用此流程，客户端必须知道服务器的域名和服务名；此外，使用说明还必须描述客户端如何获取这些信息。不建议将服务器的域名硬编码到软件中，以防该域名丢失或因法律或其他原因需要更改。

- 当客户端希望定位 **接受 Binding 请求/响应事务的 STUN 服务器(UDP/TCP)** 时，其 SRV 服务名应为`stun`。
- 当客户端希望定位 **接受通过 TLS 会话进行 Binding 请求/响应事务的 STUN 服务器(当前仅支持 TCP)** 时，其 SRV 服务名应为`stuns`。
- 其他应用场景可定义额外 SRV 服务名。

域名解析为传输地址时，采用的是 [RFC2782] 中指定的 SRV 解析过程。DNS SRV 服务名就是作为该过程输入的服务名，而 SRV 查询中的协议则是客户端运行 STUN 所采用的传输协议：对于 UDP 使用 “udp”，对于 TCP 则使用 “tcp”。注意，目前仅有 “tcp” 与 “stuns” 配合定义。

**DNS 解析流程：**
1. **SRV 记录查询**：  
   按 [RFC2782] 规范解析域名，协议字段为 `udp` 或 `tcp`。客户端按 SRV 记录排序结果依次尝试连接：  
   - 若事务超时无响应，客户端应按 RFC2782 顺序重试下一服务器。需要注意的是，此类重试仅适用于请求/响应传输，因为指示事务不会产生响应或超时。  
2. **默认端口**：  
   - **STUN（UDP/TCP）**：3478；  
   - **STUN over TLS**：5349。  
   注：服务器可在同一端口同时支持 TLS 和 TCP，需具备初始消息类型判断能力。

3. **A/AAAA 记录回退**：  
   若无 SRV 记录，客户端查询域名的  A 或 AAAA 记录，查询结果将是一系列 IP 地址，每个 IP 地址都可以在默认端口上使用 UDP 或 TCP 与服务器通信，这与具体的 STUN 用法无关。对于需要 TLS 的用法，客户端则使用默认的 STUN TLS 端口连接其中的一个 IP 地址。


## 10. 身份验证和消息完整性机制

本节定义客户端与服务器在STUN协议中使用的两种认证与消息完整性保障机制，分别为**短期凭证机制和长期凭证机制**。这两种机制属于可选实现，具体应用场景需由各使用方案明确其启用条件及适用范围。客户端和服务器通过判断当前应用场景的类型，即可确定应采用的认证机制（若有）。例如，支持ICE的公网STUN服务器通常无需认证，而执行连通性检查的代理服务器功能模块则需使用短期凭证。[第3节](#3-运行概述)已对这两种机制进行了概述。

每种机制均对基础处理流程（[第7节](#7-基本协议流程)定义）进行了扩展，规定了使用该机制所需的额外处理步骤。这些额外处理涉及三个环节：
- 消息构建阶段
- 完成基础校验后的消息接收阶段
- 错误响应详细处理阶段

### 10.1. 短期凭证机制

短期凭证机制假设在STUN事务发生前，**客户端与服务器已通过其他协议协商获得用户名和密码形式的临时凭证**。该凭证具有时效性，有效期由具体应用场景定义。

例如，在ICE应用场景[MMUSIC-ICE]中，通信双方通过带外信令协商用户名和密码，该凭证在整个媒体会话期间有效。

此类凭证用于为每个请求及多数响应生成消息完整性校验值。该机制不采用长期凭证机制中的挑战-响应模式，而是通过凭证的时效性防止重放攻击。

#### 10.1.1. 构建请求或指示

生成请求或指示消息时，代理必须在消息中包含 `USERNAME` 属性和 `MESSAGE-INTEGRITY` 属性。`MESSAGE-INTEGRITY` 属性的HMAC计算方式遵循[第15.4节](#154--message-integrity)规定。需注意，密码永不随请求或指示传输。

#### 10.1.2. 接收请求或指示

代理完成消息基础处理后，应按以下顺序执行校验：

- 若消息未同时包含 `MESSAGE-INTEGRITY` 和 `USERNAME` 属性：
  - 若为请求：服务器必须返回错误代码400（错误请求）的响应拒绝请求。
  - 若为指示：代理必须静默丢弃该指示。

- 若 `USERNAME` 中的用户名在当前服务器无效：
  - 若为请求：服务器必须返回错误代码401（未授权）的响应拒绝请求。
  - 若为指示：代理必须静默丢弃该指示。

- 使用用户名对应密码按第15.4节计算消息完整性值。若结果与 `MESSAGE-INTEGRITY` 属性值不符：
  - 若为请求：服务器必须返回错误代码401（未授权）的响应拒绝请求。
  - 若为指示：代理必须静默丢弃该指示。

所有校验通过后，代理继续处理请求或指示。服务器生成的任何响应必须包含 `MESSAGE-INTEGRITY` 属性（使用请求认证密码计算），且不得包含 `USERNAME` 属性。

**校验失败时，服务器禁止在错误响应中包含 `MESSAGE-INTEGRITY `或 `USERNAME` 属性，因无法确定用于计算消息完整性的共享密钥。**

#### 10.1.3. 接收响应

客户端检查响应中的 `MESSAGE-INTEGRITY` 属性。
- 若存在，则使用请求所用密码按第15.4节计算响应消息完整性值。
- 若与属性值匹配，则认证通过；
- 若不符或属性缺失，必须丢弃响应（视为未接收），此时若适用应继续执行重传。



### 10.2.  长期凭证机制

长期凭证机制依赖于一种长期凭证，即客户端和服务器共享的用户名和密码形式的凭证。之所以称为长期凭证，是因为假设该凭证已分配给用户，并且在用户仍为系统订阅者或未更改之前始终有效。这基本上就是传统的“登录”用户名和密码。

由于这些用户名和密码预计在较长时间内都有效，因此通过摘要质询方式提供了重放防护。在这种机制中，客户端最初发送请求时不提供任何凭证或完整性检查。服务器拒绝该请求，并向用户提供一个 realm（用于引导用户或代理选择用户名和密码）以及一个 nonce。nonce 提供了重放保护，它是由服务器选择的 Cookie，并以一种能够指示其有效期限或适用的客户端身份的方式进行编码。客户端重发请求，此时包含自己的用户名和 realm，并回显服务器提供的 nonce；同时还包含一个消息完整性值，该值为整个请求（包括 nonce）的 HMAC。服务器验证 nonce 并检查消息完整性。如果两者匹配，则请求通过认证；如果 nonce 不再有效，则被视为“陈旧的”，服务器拒绝该请求，并提供一个新的 nonce。

在后续向同一服务器发送的请求中，客户端会重用之前使用的 nonce、用户名、realm 和密码。这样，直到服务器使 nonce 失效之前，后续请求不会被拒绝；一旦 nonce 失效，拒绝响应会向客户端提供一个新的 nonce。

注意，长期凭证机制不能用于保护指示（indications），因为指示无法进行质询。使用指示的用法必须要么采用短期凭证，要么对其省略身份验证和消息完整性保护。

由于长期凭证机制容易受到离线字典攻击，部署时**应当**使用难以猜测的密码。在凭证不是由用户输入，而是在设备配置期间置于客户端设备上的情况下，密码**应当**至少具备 128 位的随机性；在凭证由用户输入的情况下，密码应遵循当前最佳的密码结构实践。

#### 10.2.1.  构造请求

  构造请求时有两种情况：第一种情况是客户端向服务器发送的第一个请求（根据使用第9节的 DNS 流程时由主机名标识，否则由 IP 地址标识）；第二种情况是客户端在之前的请求/响应事务成功完成后发送后续请求。因 401 或 438 错误响应而构造的请求在第10.2.3节中讨论，不被视为“后续请求”，因此不适用第10.2.1.2节中描述的规则。

#### 10.2.1.1.  第一个请求

    如果客户端尚未与服务器成功完成请求/响应事务（当使用 DNS 流程时由主机名标识，否则由 IP 地址标识），它**应当**省略 USERNAME、MESSAGE-INTEGRITY、REALM 和 NONCE 属性。换句话说，第一个请求发送时应当视为未进行身份验证或消息完整性保护。

#### 10.2.1.2.  后续请求

    一旦请求/响应事务成功完成，服务器会向客户端提供一个 realm 和 nonce，客户端也会选择一个用于认证的用户名和密码。客户端**应当**将该用户名、密码、realm 和 nonce 缓存起来，以便后续与服务器通信时使用。当客户端发送后续请求时，**应当**在消息中包含使用这些缓存值的 USERNAME、REALM 和 NONCE 属性，并**应当**包含一个 MESSAGE-INTEGRITY 属性，其计算方法按照第15.4节使用缓存的密码进行计算

#### 10.2.2.  接收请求

服务器在完成请求的基本处理后，按以下顺序执行检查：

- 如果消息不包含 MESSAGE-INTEGRITY 属性，服务器**必须**生成一个错误响应，错误代码为 401（Unauthorized）。该响应**必须**包含一个 REALM 值。建议该 REALM 值为 STUN 服务器提供者的域名。响应**必须**包含一个由服务器选择的 NONCE。响应**不应**包含 USERNAME 或 MESSAGE-INTEGRITY 属性。

- 如果消息包含 MESSAGE-INTEGRITY 属性，但缺少 USERNAME、REALM 或 NONCE 属性，服务器**必须**生成一个错误响应，错误代码为 400（Bad Request）。该响应**不应**包含 USERNAME、NONCE、REALM 或 MESSAGE-INTEGRITY 属性。

- 如果 NONCE 不再有效，服务器**必须**生成一个错误响应，错误代码为 438（Stale Nonce）。该响应**必须**包含 NONCE 和 REALM 属性，并**不应**包含 USERNAME 或 MESSAGE-INTEGRITY 属性。服务器可以使 nonce 失效以提供额外安全性（参见 [RFC2617] 第4.3节的指南）。

- 如果 USERNAME 属性中的用户名无效，服务器**必须**生成一个错误响应，错误代码为 401（Unauthorized）。该响应**必须**包含一个 REALM 值，建议该 REALM 值为 STUN 服务器提供者的域名；同时响应**必须**包含由服务器选择的 NONCE，并**不应**包含 USERNAME 或 MESSAGE-INTEGRITY 属性。

- 使用 USERNAME 属性中与该用户名关联的密码，根据第15.4节描述计算消息完整性值。如果计算结果与 MESSAGE-INTEGRITY 属性的内容不匹配，服务器**必须**拒绝该请求并生成错误响应。该响应**必须**使用错误代码 401（Unauthorized），**必须**包含 REALM 和 NONCE 属性，并**不应**包含 USERNAME 或 MESSAGE-INTEGRITY 属性。

如果上述检查全部通过，服务器继续处理请求。服务器生成的任何响应（除上述情况外）**必须**包含 MESSAGE-INTEGRITY 属性，该属性使用用于认证请求的用户名和密码计算得出；而 REALM、NONCE 和 USERNAME 属性**不应**包含在响应中。

#### 10.2.3.  接收响应

如果响应是错误响应，错误代码为 401（Unauthorized），客户端**应当**在一个新事务中重试该请求。此请求**必须**包含一个由客户端确定的、与错误响应中 REALM 相匹配的合适用户名；请求**必须**包含从错误响应中复制的 REALM；**必须**包含从错误响应中复制的 NONCE；**必须**包含一个 MESSAGE-INTEGRITY 属性，其计算方法使用与 USERNAME 属性中所列用户名关联的密码。客户端如果没有更改 USERNAME、REALM 或其关联的密码，则**不得**执行此重试。

如果响应是错误响应，错误代码为 438（Stale Nonce），客户端**必须**重试该请求，并使用 438（Stale Nonce）响应中提供的新 NONCE。此重试请求**也必须**包含 USERNAME、REALM 和 MESSAGE-INTEGRITY 属性。

客户端在响应（无论成功或失败）中查找 MESSAGE-INTEGRITY 属性；如果存在，客户端按照第15.4节的定义使用其在请求中使用的相同密码计算响应的消息完整性值。如果计算结果与 MESSAGE-INTEGRITY 属性内容匹配，则响应被视为已通过认证；如果不匹配，或缺少 MESSAGE-INTEGRITY 属性，则**必须**丢弃该响应，就好像从未收到一样。这意味着（如适用）重传将继续进行。

## 11. ALTERNATE-SERVER 机制

本节介绍了 STUN 中的一种机制，该机制允许服务器将客户端重定向到另一台服务器。该扩展是可选的，每种具体用法都必须定义是否以及何时使用该扩展。

**服务器行为：**
当服务器需重定向客户端时，回复一个 **错误码为 300（Try Alternate）** 的错误响应消息，必须包含 `ALTERNATE-SERVER` 属性。虽然错误响应消息可以经行身份验证，但在某些使用场景中，响应的身份验证可能既不现实也不可行。

**客户端处理逻辑：**
在收到错误码为 300（Try Alternate）的响应时，会首先查找该响应中的 `ALTERNATE-SERVER` 属性；
- 如果找到了，客户端便认为当前事务失败，并使用与上一次请求相同的传输协议，重新向属性中指定的服务器发送请求。
- 如果该请求需要经过身份验证，则必须使用客户端在向执行重定向的服务器发送请求时所使用的相同凭证。
- 如果客户端在过去五分钟内已经尝试过向该服务器发送此请求，则必须忽略此次重定向并将事务视为失败，以**避免在重定向循环中服务器之间无限来回切换**。

## 12. 与 RFC 3489 向后兼容性

本节定义了一套程序，使得新旧版本之间能够在一定程度上实现兼容。这一机制是可选的，仅在新客户端需要与旧服务器互联，或旧客户端需要与新服务器互联的情况下使用。具体用法必须明确定义在何时以及如何使用该机制。

[第 19 节]()列出了本规范与 RFC 3489 之间的所有变化，但并非所有差异都十分关键，因为“经典 STUN”仅在少数特定场景中使用。对于本扩展来说，主要的变化包括：
- 在 RFC 3489 中，仅支持 UDP 传输；
- 原本现在称为 `magic cookie` 的字段当时是交易 ID 字段的一部分，且交易 ID 长度为 128 位；
- 不存在 `XOR-MAPPED-ADDRESS` 属性，Binding 方法使用的是 `MAPPED-ADDRESS` 属性；
> RFC 3489 中要求必须理解的三个属性—`—RESPONSE-ADDRESS`、`CHANGE-REQUEST` 和 `CHANGED-ADDRESS`——已从本规范中移除，其中 `CHANGE-REQUEST` 和 `CHANGED-ADDRESS` 现已成为 NAT 行为发现用法的一部分，而另一个属性则被废弃。

### 12.1 客户端处理的更改

希望与 RFC 3489 服务器互操作的客户端，应该发送一个使用 Binding 方法、没有包含任何属性且采用 UDP 作为传输协议的请求消息。如果请求成功，服务器返回的成功响应中将包含 MAPPED-ADDRESS 属性而不是 XOR-MAPPED-ADDRESS 属性。试图与旧服务器互操作的客户端必须能够处理这两种属性。此外，客户端必须忽略响应中可能出现的任何预留的、要求必须理解的属性。在 RFC 3489 中预留的属性（例如 0x0002、0x0004、0x0005 和 0x000B）可能会出现在符合 RFC 3489 规范的服务器返回的 Binding 响应中。除此之外，响应的处理过程与前面描述的程序完全一致。

### 12.2 服务器处理的更改

STUN 服务器可以通过检查 Binding 请求消息中 magic cookie 字段的值，来判断该请求是否来自 RFC 3489 客户端。如果检测到请求来自 RFC 3489 客户端，服务器应将请求中所看到的 magic cookie 字段的值复制到响应消息中的相应字段，并在响应中插入 MAPPED-ADDRESS 属性，而不是 XOR-MAPPED-ADDRESS 属性。

在极少数情况下，客户端可能会包含 RESPONSE-ADDRESS 或 CHANGE-REQUEST 属性，此时服务器会将这些属性视为未知的、必须理解的属性，并以错误响应回复。由于使用这些属性的机制已不再支持，因此这种行为是可以接受的。

由于 RFC 3489 版本的 STUN 不包含 magic cookie 和 FINGERPRINT 属性，这些属性能在多协议复用时大大提高正确识别 STUN 消息的概率，因此要求向后兼容 RFC 3489 的实现，在复用其他协议的场景中不应使用 RFC 3489 模式。不过，这通常不会成为问题，因为在 RFC 3489 中并没有支持这种复用



### 13. 基本服务器行为

本节定义独立 STUN 服务器的基本功能：通过处理 Binding 请求为客户端提供服务器反射传输地址。

#### 核心要求
1. **方法支持**：必须支持 Binding 方法。  
2. **认证机制**：不建议使用短期或长期凭证（认证开销高于处理请求本身）。  
3. **传输协议**：必须支持 UDP 和 TCP，可选支持 TLS（但 TLS 在基础模式中安全性收益有限）。  
4. **兼容性**：应支持 RFC 3489 客户端（见第 12 章），且不得强制要求指纹机制（以免破坏兼容性）。  

#### 部署建议
- **DNS 配置**：建议按第 9 节配置 SRV 记录，便于客户端发现服务器。  
- **功能定位**：独立 STUN 服务器本身不解决 NAT 穿透问题，但可通过 STUN 应用场景（如 ICE）作为解决方案的一部分。  



## 14.  STUN 用法

STUN 本身并不是 NAT 穿越问题的解决方案，而是定义了一种可在更大解决方案中使用的工具。“STUN 用法”这一术语用于指代任何将 STUN 作为组成部分的解决方案。

在本文撰写时，已定义了三种 STUN 用法：
- 交互式连通性建立（Interactive Connectivity Establishment, ICE）[MMUSIC-ICE]
- SIP 客户端发起的连接 [SIP-OUTBOUND]
- NAT 行为发现 [BEHAVE-NAT]。
 
未来可能还会定义其他 STUN 用法。

一个 STUN 用法定义了 STUN 的实际使用方式——何时发送请求、如何处理响应，以及使用本规范（或 STUN 扩展中）定义的哪些可选流程。一个用法还将定义：

- 使用哪些 STUN 方法。
- 使用何种身份验证和消息完整性机制。
- 关于完整性机制中手动与自动密钥派生的考虑，如 [RFC4107] 中所讨论的。
- 用于区分 STUN 消息与其他消息的机制。当 STUN 运行于 TCP 上时，可能需要采用一种分帧机制。
- STUN 客户端如何确定 STUN 服务器的 IP 地址和端口。
- 是否需要向后兼容 RFC 3489。
- 要求使用哪些在本规范（例如 FINGERPRINT 和 ALTERNATE-SERVER）或其他扩展中定义的可选属性。

此外，任何 STUN 用法都必须考虑在该用法中使用 STUN 的安全影响。已知存在针对 STUN 的多种攻击（详见本文件的安全考虑部分），因此任何用法都必须考虑如何防止或缓解这些攻击。

最后，一个用法必须考虑其对 STUN 的使用是否属于单边自地址修正（Unilateral Self-Address Fixing）方法以实现 NAT 穿越，如果是，则应解决 RFC 3424 [[RFC3424]]() 中提出的问题。

## 15. STUN 属性

STUN 消息头部之后可包含零个或多个属性。每个属性采用 TLV（类型-长度-值）编码格式，，即包含一个 16 位的类型、16 位的长度和对应的变长值。所有属性必须按 32 位对齐，且字段均以大端字节序传输。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Type                  |            Length             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Value (variable)                ....
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图4：STUN 属性的格式**

**长度字段**表示值的实际字节数（不含填充）。若值长度非 4 字节的倍数，需在尾部填充 1-3 字节的任意值以满足对齐要求，填充内容可被忽略。

在 STUN 消息中，任何属性类型可以出现多次。除非另有说明，属性的出现顺序是有意义的：**接收方只需要处理第一次出现的该属性，其余重复出现的属性可以被忽略**。

为了便于将来对本规范的修订时根据需要添加新属性，属性(Type)空间被划分为两个范围。
- 0x0000 - 0x7FFF: “必须理解”属性，这意味着 STUN 代理如果不理解该属性，将无法成功处理消息；
- 0x8000 - 0xFFFF: 可选理解”属性，这意味着如果 STUN 代理不理解这些属性，可以将其忽略。

STUN 属性类型的集合由 IANA 进行维护。本规范中定义的初始属性集合见于[第 18.2 节]()。

本节余下部分描述了本规范中定义的各个属性的格式。

### 15.1. MAPPED-ADDRESS

MAPPED-ADDRESS 属性表示客户端的反射传输地址。它由一个 8 位的地址族和一个 16 位的端口组成，后跟一个固定长度的值表示 IP 地址。如果地址族为 IPv4，则地址必须为 32 位；如果地址族为 IPv6，则地址必须为 128 位。所有字段均须采用网络字节序。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 0 0 0|    Family     |           Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                 Address (32 bits or 128 bits)                 |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图5：MAPPED-ADDRESS 属性的格式**

地址族（Family）可以取以下值：
- `0x01`：IPv4
- `0x02`：IPv6
  
MAPPED-ADDRESS 的**前 8 位必须设置为 0**，并且接收方必须忽略这些位。这些位的存在是为了使参数在自然的 32 位边界上对齐。

该属性仅由服务器使用，以实现与 RFC 3489 [[RFC3489]]() 客户端的向后兼容


### 15.2. XOR-MAPPED-ADDRESS

XOR-MAPPED-ADDRESS 属性功能与 MAPPED-ADDRESS 相同，但其反射传输地址通过 XOR 运算进行了混淆。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |x x x x x x x x|    Family     |         X-Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                X-Address (Variable)
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图6：XOR-MAPPED-ADDRESS 属性的格式**
其中，Family 表示 IP 地址族，其编码方式与 MAPPED-ADDRESS 中的 Family 相同。
- **编码规则**：  
  - **X-Port**：将主机的端口号与魔术字（Magic Cookie）的高 16 位异或后转为网络字节序。  
  - **X-Address**：  
    - IPv4：取映射的 IP 地址（以主机字节序表示）与魔术字异或后转为网络字节序。  
    - IPv6：取映射的 IP 地址（以主机字节序表示）与魔术字及 96 位事务 ID 拼接值异或后转为网络字节序。  
 
对于属性值的前 8 位的编码和处理规则、处理属性多次出现的规则以及地址族的处理规则，与 MAPPED-ADDRESS 完全相同。

>XOR-MAPPED-ADDRESS 与 MAPPED-ADDRESS 仅在传输地址的编码方式上有所不同。前者通过将传输地址与 magic cookie 进行异或运算来编码，而后者则直接以二进制方式编码。RFC 3489 最初仅规定了 MAPPED-ADDRESS，但实际部署经验发现，一些 NAT 会重写包含 NAT 公网 IP 地址的 32 位二进制负载（如 STUN 的 MAPPED-ADDRESS 属性），这种出于提供通用 ALG 功能的善意但错误的尝试，会干扰 STUN 的正常运行，并导致 STUN 的消息完整性检查失败。

下面是第15章后续部分的中文翻译，原文的列表划分已予保留：



### 15.3.  USERNAME

USERNAME 属性用于消息完整性校验，标识消息完整性检查中使用的用户名与密码组合。其值为变长字段，要求：
- Value 采用 UTF-8 编码（RFC 3629），长度小于 513 字节；
- **必须经过 SASLprep [RFC4013] 规范化处理**。

### 15.4.  MESSAGE-INTEGRITY

`MESSAGE-INTEGRITY` 属性包含 STUN 消息的 `HMAC-SHA1`（[RFC 2104]()）校验值，长度固定为 20 字节。该校验值基于整个 STUN 消息计算（含头部及 `MESSAGE-INTEGRITY` 之前的所有属性）。除位于 `MESSAGE-INTEGRITY` 之后的 `FINGERPRINT` 属性外，代理**必须忽略所有跟在 `MESSAGE-INTEGRITY` 属性之后的其他属性**。

HMAC 所用密钥取决于所使用的是长期凭证还是短期凭证。

**对于长期凭证，密钥为 16 字节，其计算方法为：**
\[ key = MD5(username ":" realm ":" SASLprep(password)) \]

也就是说，该 16 字节密钥是通过将下列五个字段依次串联后计算 MD5 哈希得到的：
  1. 从 USERNAME 属性中获得的用户名（已去除引号和尾随的空字符，此时已经经过 SASLprep 规范化处理）
  2. 一个冒号
  3. 去除引号和尾随空字符的 realm（域）
  4. 一个冒号
  5. 经过 SASLprep 处理且去除尾随空字符的密码。
  例如，如果用户名为 "user"、realm 为 "realm"、密码为 "pass"，则 16 字节的 HMAC 密钥就是对字符串 "user:realm:pass" 进行 MD5 哈希后得到的结果，即 0x8493fbc53ba582fb4c044c456bdc40eb。

**对于短期凭证，则有：**

\[ key = SASLprep(password) \]

>其中，MD5 定义见 RFC 1321 [RFC1321]，而 SASLprep() 定义见 RFC 4013 [RFC4013]。

采用长期凭证时密钥的结构有助于在同时使用 SIP 的系统中进行部署。通常，采用 SIP 摘要认证机制的 SIP 系统不会在数据库中存储实际密码，而是存储一个称为 H(A1) 的值，该值等同于上述定义的密钥。

根据上述规则，用于构造 MESSAGE-INTEGRITY 的哈希值会包括 STUN 消息头中的长度字段。
- 在执行哈希计算之前，必须先将 MESSAGE-INTEGRITY 属性插入到 STUN 消息中（其内容可先填入一个占位值）。
- 接着，长度字段必须设置为表示从消息起始到（并包含）MESSAGE-INTEGRITY 属性本身部分的长度，但不包括其后任何属性。
- 计算完成后，再将正确的 MESSAGE-INTEGRITY 值填入该属性，并将 STUN 消息头中的长度字段更新为整个消息的实际长度。
- 同样，在验证 MESSAGE-INTEGRITY 时，应先将长度字段调整为指向 MESSAGE-INTEGRITY 属性末尾，再计算 HMAC。当 MESSAGE-INTEGRITY 后面还存在诸如 FINGERPRINT 等属性时，这种调整是必要的。

### 15.5.  FINGERPRINT

FINGERPRINT 属性可以出现在所有 STUN 消息中。该属性的值通过以下方式计算得出：

- 对 STUN 消息（直至但不包括 FINGERPRINT 属性本身）计算 CRC-32，然后将结果与 32 位值 0x5354554e（ASCII "STUN"） 进行异或运算（异或操作有助于在应用数据包中也使用 CRC-32 的情况下区分开来）。
> 该 32 位 CRC 依据 ITU V.42 [ITU.V42.2002] 定义，其生成多项式为  
\[x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} + x^{11} + x^{10} + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\]

当 FINGERPRINT 属性存在时，**必须将其作为消息中的最后一个属性**，因此它将出现在 MESSAGE-INTEGRITY 属性之后。

FINGERPRINT 属性有助于将 STUN 数据包与其他协议的数据包区分开来（参见第8节）。

与 MESSAGE-INTEGRITY 类似，FINGERPRINT 属性所使用的 CRC 计算也覆盖了 STUN 消息头中的长度字段。**因此，在计算 CRC 之前，该长度值必须正确，并且应将 CRC 属性视为消息长度的一部分。在使用 FINGERPRINT 属性时，应先将其以占位值插入消息中，然后计算 CRC，最后更新该属性的值。** 如果消息中同时存在 MESSAGE-INTEGRITY 属性，则在计算 CRC 前，MESSAGE-INTEGRITY 属性必须已包含正确的消息完整性值，因为 CRC 的计算也涵盖了该属性的内容。

### 15.6.  ERROR-CODE

ERROR-CODE 属性用于错误响应消息。它包含一个数值错误代码（范围为 300 至 699）以及一个以 UTF-8 [RFC3629] 编码的文本原因短语，其代码分配和语义与 SIP [RFC3261] 及 HTTP [RFC2616] 保持一致。该原因短语供用户查看，可以是与错误代码相适应的任意内容。对于各错误代码，推荐的原因短语已包含在 IANA 的错误代码注册表中。**原因短语必须为 UTF-8 [RFC3629] 编码的序列，字符数少于 128 个（其字节数最多可达 763 字节）**。

    
```
        0                   1                   2                   3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved, should be 0         |Class|     Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Reason Phrase (variable)                                ..
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图7：ERROR-CODE 属性**

为便于处理，错误代码的类别（即错误代码的百位数字）被单独编码，与代码的其他部分分开，如图7所示。

- 保留位（Reserved）应为 0，用于在 32 位边界上的对齐；接收方必须忽略这些位。
- Class 表示错误代码的百位数字，其值**必须**介于 3 到 6 之间
- Number 表示错误代码除以 100 后的余数，其值**必须**介于 0 到 99 之间
- Reason Phrase，表示原因，UTF-8 编码，长度小于 128 字符（763 字节）

定义了以下错误代码及其推荐的原因短语：

- 300  Try Alternate：客户端应就此请求联系另一台服务器。**仅当请求中包含 USERNAME 属性和有效的 MESSAGE-INTEGRITY 属性时，才发送该错误响应**；否则不得发送，建议使用错误代码 400（Bad Request）。该错误响应必须由 MESSAGE-INTEGRITY 属性保护，接收方在将自己重定向至另一服务器前，必须验证该响应的 MESSAGE-INTEGRITY。

>注意：如果未能为 300 响应生成并验证消息完整性，将可能使路径上的攻击者伪造 300 响应，从而导致后续 STUN 消息被错误地发送给受害者。

- 400  Bad Request：请求格式错误。客户端不应在未对先前请求做出修改的情况下重试。服务器可能无法为此错误生成有效的 MESSAGE-INTEGRITY，因此客户端不得期望响应中包含有效的 MESSAGE-INTEGRITY 属性。

- 401  Unauthorized：请求中未包含正确的凭证以继续。客户端应使用正确凭证重试该请求。

- 420  Unknown Attribute：服务器收到的 STUN 数据包中包含一个要求必须理解但其内容无法识别的属性。服务器**必须**将该未知属性放入错误响应中的 UNKNOWN-ATTRIBUTE 属性中。

- 438  Stale Nonce：客户端使用的 NONCE 已不再有效。客户端应使用响应中提供的 NONCE 重试该请求。

- 500  Server Error：服务器遭遇临时错误。客户端应重试该请求。


### 15.7.  REALM

REALM 属性可以出现在请求和响应中。它包含的文本须符合 RFC 3261 [RFC3261] 中描述的 "realm-value" 语法，但不包括双引号及其周围的空白。也就是说，它是一个未加引号的 realm-value（因此是 `qdtext` 或 `quoted-pair` 的序列）。要求：
- Value必须是一个 UTF-8 [RFC3629] 编码的序列，字符数少于 128 个（可达 763 字节
- **必须经过 SASLprep [RFC4013] 处理**。

请求中出现 REALM 属性表示正在使用长期凭证进行身份验证；在某些错误响应中出现则表示服务器希望客户端使用长期凭证进行身份验证。

### 15.8.  NONCE

NONCE 属性可以出现在请求和响应中。它包含一系列 `qdtext` 或 `quoted-pair`（定义见 RFC 3261 [RFC3261]）。注意，这意味着 NONCE 属性中不会包含实际的引号字符。有关服务器中 nonce 值选择的指导，请参见 RFC 2617 [RFC2617] 第 4.3 节。

- **格式要求**：必须少于 128 个字符（可达 763 字节）。

### 15.9.  UNKNOWN-ATTRIBUTES

UNKNOWN-ATTRIBUTES 属性仅出现在错误码为 `420（Unknown Attribute）` 的错误响应中，用于列出服务器无法识别的必须理解属性类型。

该属性包含一系列 16 位值，每个值代表一个服务器无法理解的属性类型。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Attribute 1 Type           |     Attribute 2 Type        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Attribute 3 Type           |     Attribute 4 Type    ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图8：UNKNOWN-ATTRIBUTES 属性的格式**

>注意：在 [RFC3489] 中，此字段通过复制最后一个属性进行填充至 32 位；而在本版本的规范中，则采用了属性的正常填充规则。

### 15.10.  SOFTWARE

SOFTWARE 属性包含发送消息的代理所使用软件的文本描述。该属性既由客户端使用，也由服务器使用。其值**应该包含制造商信息和版本号**。该属性对协议操作没有影响，仅作为诊断和调试的工具。SOFTWARE 的值为可变长度数据，
- **格式要求**：必须为 UTF-8 [RFC3629] 编码的序列，字符数少于 128 个（可达 763 字节）。

### 15.11.  ALTERNATE-SERVER

Alternate-Server 表示一个备用的传输地址，用以标识 STUN 客户端应尝试连接的另一台 STUN 服务器。

该属性的编码方式与 MAPPED-ADDRESS 相同，因此通过 IP 地址引用单个服务器。请求源 IP 地址的地址族**必须**与此备用服务器所使用的 IP 地址族相同。



## 16.  安全考虑

### 16.1.  针对协议的攻击

#### 16.1.1.  外部攻击

攻击者可以尝试在 STUN 消息传输过程中篡改消息，以导致 STUN 运行失败。这类攻击无论针对请求还是响应，都**可通过消息完整性机制检测出来**，无论使用短期凭证还是长期凭证。当然，一旦检测出被篡改的数据包，这些数据包将被丢弃，从而使得整个 STUN 事务实际上失败。此类攻击仅可能由处于数据传输路径上的攻击者发起。

如果一个能够观察但无法修改传输中 STUN 消息的攻击者（例如，处于共享接入介质上的攻击者，如 Wi-Fi 网络中的攻击者）可以看到一个 STUN 请求，然后立即发送一个 STUN 响应（通常为错误响应），便可扰乱 STUN 的处理。
- 采用 `MESSAGE-INTEGRITY` 可防范此攻击。然而，一些错误响应（尤其是与认证相关的响应）无法通过 MESSAGE-INTEGRITY 进行保护。
- **当 STUN 本身运行在安全传输协议（例如 TLS）之上时，这些攻击将得到完全缓解。**

根据 STUN 的不同用法，这些攻击可能带来的后果较小，从而不需要通过消息完整性来加以缓解。例如，当 STUN 被用于基本的 STUN 服务器上以发现用于 ICE 的服务器反射候选地址时，由于在连通性检查阶段即可检测到这些攻击，因此不要求进行认证和消息完整性保护。不过，连通性检查本身却需要保护，以保证 ICE 整体的正常运行。如[第14节]()所述，各 STUN 用法会说明何时需要认证和消息完整性保护。

由于 STUN 使用共享密钥的 HMAC 进行认证和完整性保护，因此容易受到离线字典攻击。当使用认证时，**应当使用不易受到离线字典攻击的强密码。** 使用 TLS 来保护信道可以缓解这些攻击；然而，STUN 通常运行于 UDP 上，在这种情况下，**只有使用强密码才能防范此类攻击。**

#### 16.1.2.  内部攻击

  恶意客户端可能通过向服务器发送大量 STUN 请求来发起拒绝服务（DoS）攻击。幸运的是，服务器可以无状态地处理 STUN 请求，这使得这种攻击较难实施。

  恶意客户端还可能利用 STUN 服务器作为反射器，向其发送源 IP 地址和端口伪造的请求。这样，服务器的响应就会发送到那个伪造的源 IP 和端口。虽然这种攻击不会造成数据包数量的放大（服务器每收到一个客户端数据包只发送一个响应数据包），但由于 STUN 响应通常大于请求，因此会略微增加数据量。通过入口源地址过滤可以缓解这类攻击。

  通过 SOFTWARE 属性泄露代理所使用的软件具体版本，可能会使其更容易受到已知存在安全漏洞的软件攻击。实现者**应当将 SOFTWARE 属性的使用设计为可配置选项**。

### 16.2.  影响 STUN 用法的攻击

  本节列举了可能针对某个 STUN 用法发起的攻击。每种 STUN 用法必须考虑这些攻击是否适用于自身，并在适用时讨论相应的对策。

  本节中的大多数攻击都围绕着攻击者通过 Binding 请求/响应事务篡改 STUN 客户端获取到的反射地址展开。由于反射地址的使用取决于具体的用法，因此这些攻击的适用性和补救措施都是用法特定的。在常见情况下，处于数据传输路径上的攻击者篡改反射地址非常容易。
例如，在 STUN 直接运行于 UDP 上的常见情形中，攻击者可以在 Binding 请求到达 STUN 服务器之前篡改其源 IP 地址。这样，STUN 服务器会将该（伪造的）IP 地址在 XOR-MAPPED-ADDRESS 属性中返回，并将响应发送至该伪造的 IP 地址和端口。如果攻击者还能截获该响应，则可将响应重定向回客户端。通过使用消息完整性检查来防止此攻击是不可能的，因为消息完整性值无法覆盖源 IP 地址（由于中间 NAT 必须能够修改该地址）。因此，**防范下述攻击的一种解决方案是让客户端验证其获取到的反射地址**，正如 ICE [MMUSIC-ICE] 中所做的那样。其他用法也可以采用其它手段来防范此类攻击。

#### 16.2.1 攻击 I：对目标的分布式拒绝服务（DDoS）
**攻击原理：**
攻击者诱导多个客户端使用伪造的反射地址（指向目标），导致目标接收大量本应发往客户端的流量。

**限制条件：**
需攻击者位于 STUN 服务器至目标的路径上。

#### 16.2.2 攻击 II：静默客户端
**攻击原理：**
伪造反射地址指向无效地址，使客户端无法接收预期流量。

**影响范围：**
仅影响单个客户端，且攻击者可通过其他方式（如阻断 STUN 响应）实现相同效果。

#### 16.2.3 攻击 III：冒充客户端身份
**攻击原理：**
伪造反射地址指向攻击者自身，劫持本应发往客户端的流量。
**数据窃取：**
攻击者可获取目标客户端的通信内容。

#### 16.2.4 攻击 IV：窃听
**攻击原理：**
伪造反射地址指向自身并转发流量至客户端，实现流量监听。

**限制条件：**
攻击者需已具备监听客户端至 STUN 服务器流量的能力。

**通用防御方案：**

- 应用场景需验证反射地址有效性（如 ICE 的连通性检查机制）；
- 使用消息完整性校验与安全传输协议。



### 16.3.  哈希算法灵活性计划

  本规范采用 HMAC-SHA-1 来计算消息完整性。如果在未来 HMAC-SHA-1 被发现存在安全问题，则将采取如下补救措施：

  我们将定义一个 STUN 扩展，引入一个使用新哈希算法计算的新消息完整性属性。客户端将被要求在其请求或指示中同时包含新旧两种消息完整性属性。新服务器将使用新的消息完整性属性，而旧服务器则继续使用旧的。经过一段混合实现共存的过渡期后，旧的消息完整性属性将由另一份规范宣布废弃，客户端也将停止在请求中包含该属性。

  另外需要注意的是，HMAC 的计算使用的密钥本身是通过对用户密码进行 MD5 计算得到的。选择 MD5 散列算法是因为存在一些遗留数据库以这种形式存储密码。如果将来研究发现基于 MD5 输入的 HMAC 不够安全，需要采用其它散列算法，也可依据上述计划进行更换，但这将要求管理员重新填充其数据库。

## 17.  IAB 考虑事项

AB 已经研究了“单边自地址修正（Unilateral Self-Address Fixing, UNSAF）”问题，即客户端通过协作式协议反射机制（见 RFC3424 [RFC3424]）尝试确定其位于 NAT 另一侧其他域中的地址的通用过程。如果一个代理位于 NAT 内部，而另一个代理位于 NAT 的公网侧，则 STUN 可利用 Binding 请求/响应事务来实现这一功能。

IAB 要求为此目的开发的协议必须记录一系列特定的考虑事项。由于某些 STUN 用法（例如 ICE [MMUSIC-ICE]）提供 UNSAF 功能，而其他用法（例如 SIP Outbound [SIP-OUTBOUND]）则不提供，因此这些考虑事项的答案需要由各自的用法自行解决。

## 18.  IANA 考虑事项

IANA 已创建了三个新的注册表：
- STUN 方法注册表（STUN Methods Registry）
- STUN 属性注册表（STUN Attributes Registry）
- STUN 错误代码注册表（STUN Error Codes Registry）
同时，IANA 还将 STUN 分配的 IANA 端口名称从 “nat-stun-port” 更改为 “stun”。

### 18.1.  STUN 方法注册表

STUN 方法是一个范围在 0x000 到 0xFFF 内的十六进制数。STUN 方法在 STUN 消息中的编码方式见第6节。

初始的 STUN 方法如下：
- 0x000： (保留)
- 0x001： Binding
- 0x002： (保留；原为 SharedSecret)

>范围 0x000 - 0x7FF 内的 STUN 方法由 IETF Review 分配 [RFC5226]；范围 0x800 - 0xFFF 内的 STUN 方法由 Designated Expert 分配 [RFC5226]。

专家的职责在于验证所选代码点未被使用，并且请求的代码点数量不异常。扩展本身的技术评审不在该专家的职责范围内。

### 18.2.  STUN 属性注册表

STUN 属性类型是一个范围在 0x0000 到 0xFFFF 内的十六进制数。范围在 0x0000 到 0x7FFF 内的 STUN 属性类型被视为“必须理解”的属性；而范围在 0x8000 到 0xFFFF 内的属性类型则被视为“可选理解”的属性。STUN 代理对未知的“必须理解”和“可选理解”属性的处理方式有所不同。

初始的 STUN 属性类型如下：

**必须理解范围（0x0000-0x7FFF）：**  
- 0x0000： (保留)  
- 0x0001： MAPPED-ADDRESS  
- 0x0002： (保留；原为 RESPONSE-ADDRESS)  
- 0x0003： (保留；原为 CHANGE-ADDRESS)  
- 0x0004： (保留；原为 SOURCE-ADDRESS)  
- 0x0005： (保留；原为 CHANGED-ADDRESS)  
- 0x0006： USERNAME  
- 0x0007： (保留；原为 PASSWORD)  
- 0x0008： MESSAGE-INTEGRITY  
- 0x0009： ERROR-CODE  
- 0x000A： UNKNOWN-ATTRIBUTES  
- 0x000B： (保留；原为 REFLECTED-FROM)  
- 0x0014： REALM  
- 0x0015： NONCE  
- 0x0020： XOR-MAPPED-ADDRESS

**可选理解范围（0x8000-0xFFFF）：**  
- 0x8022： SOFTWARE  
- 0x8023： ALTERNATE-SERVER  
- 0x8028： FINGERPRINT

>在必须理解范围的前半部分（0x0000 - 0x3FFF）以及可选理解范围的前半部分（0x8000 - 0xBFFF）内的 STUN 属性类型由 IETF Review 分配 [RFC5226]；而必须理解范围的后半部分（0x4000 - 0x7FFF）以及可选理解范围的后半部分（0xC000 - 0xFFFF）内的属性类型则由 Designated Expert 分配 [RFC5226]。

专家的职责在于验证所选代码点未被使用，并且请求的代码点数量不异常。扩展本身的技术评审不在该专家的职责范围内。

### 18.3.  STUN 错误代码注册表

STUN 错误代码是一个范围在 0 到 699 内的数字。每个 STUN 错误代码都附带一个以 UTF-8 [RFC3629] 编码的文本原因短语，该短语仅供人类阅读，可为任意合适的内容；本文档仅提出建议值。

STUN 错误代码在代码点分配和语义上与 SIP [RFC3261] 和 HTTP [RFC2616] 保持一致。

该注册表中的初始值见[第15.6节](#156--error-code)。

新的 STUN 错误代码根据 IETF Review 分配 [RFC5226]。规范必须仔细考虑不理解该错误代码的客户端在处理时会如何表现，然后再批准该请求。详见第7.3.4节中的规则。

### 18.4.  STUN UDP 和 TCP 端口号

IANA 之前已为 STUN 分配端口 3478。该端口在 IANA 注册表中以 “nat-stun-port” 为名出现。为了使 DNS SRV 流程与注册的协议服务名称保持一致，IANA 被请求将分配给端口 3478 的协议名称从 “nat-stun-port” 改为 “stun”，并将文本名称从 “Simple Traversal of UDP Through NAT (STUN)” 改为 “Session Traversal Utilities for NAT”，使得 IANA 端口注册表中显示如下：

- stun   3478/tcp   Session Traversal Utilities for NAT (STUN) port  
- stun   3478/udp   Session Traversal Utilities for NAT (STUN) port

  此外，IANA 已为 “stuns” 服务分配了端口号 5349，该服务适用于 TCP 和 UDP。UDP 端口目前尚未定义，但已保留以供将来使用。

