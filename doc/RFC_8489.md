- [1. 引言](#1-引言)
- [2. 运行概述](#2-运行概述)
- [3. 术语](#3-术语)
- [4. 定义](#4-定义)
- [5. STUN 消息结构](#5-stun-消息结构)
  - [STUN Message Type](#stun-message-type)
  - [Magic Cookie](#magic-cookie)
  - [Transaction ID](#transaction-id)
  - [Message Length](#message-length)
- [6. 基本协议流程](#6-基本协议流程)
  - [6.1. 构造请求或指示消息](#61-构造请求或指示消息)
  - [6.2. 发送请求或指示消息](#62-发送请求或指示消息)
    - [6.2.1. 通过 UDP 或 DTLS-over-UDP 发送](#621-通过-udp-或-dtls-over-udp-发送)
    - [6.2.2. 通过 TCP 或 TLS-over-TCP 发送](#622-通过-tcp-或-tls-over-tcp-发送)
    - [6.2.3. 通过 TLS-over-TCP 或 DTLS-over-UDP 发送](#623-通过-tls-over-tcp-或-dtls-over-udp-发送)
  - [6.3 接收 STUN 消息](#63-接收-stun-消息)
    - [6.3.1 处理请求](#631-处理请求)
      - [6.3.1.1 构建成功或错误响应](#6311-构建成功或错误响应)
      - [6.3.1.2 发送成功或错误响应](#6312-发送成功或错误响应)
    - [6.3.2 处理指示（Indication）](#632-处理指示indication)
    - [6.3.3 处理成功响应](#633-处理成功响应)
    - [6.3.4 处理错误响应](#634-处理错误响应)
- [7. FINGERPRINT 机制](#7-fingerprint-机制)
- [8. 基于 DNS 的服务器发现](#8-基于-dns-的服务器发现)
  - [8.1. STUN URI Scheme 语义](#81-stun-uri-scheme-语义)
- [9. 身份验证和消息完整性机制](#9-身份验证和消息完整性机制)
  - [9.1. 短期凭证机制](#91-短期凭证机制)
    - [9.1.1.  HMAC 密钥](#911--hmac-密钥)
    - [9.1.2. 构建请求或指示](#912-构建请求或指示)
    - [9.1.3. 接收请求或指示](#913-接收请求或指示)
    - [9.1.4. 接收响应](#914-接收响应)
  - [9.2.  长期凭证机制](#92--长期凭证机制)
- [10. ALTERNATE-SERVER 机制](#10-alternate-server-机制)
- [11. 与 RFC 3489 向后兼容性](#11-与-rfc-3489-向后兼容性)
  - [11.1 客户端处理的更改](#111-客户端处理的更改)
  - [11.2 服务器处理的更改](#112-服务器处理的更改)
- [12. 基本服务器行为](#12-基本服务器行为)
    - [核心要求](#核心要求)
    - [部署建议](#部署建议)
- [13.  STUN 用法](#13--stun-用法)
- [14. STUN 属性](#14-stun-属性)
  - [14.1. MAPPED-ADDRESS](#141-mapped-address)
  - [14.2. XOR-MAPPED-ADDRESS](#142-xor-mapped-address)
  - [14.3.  USERNAME](#143--username)
  - [14.4.  USERHASH](#144--userhash)
  - [14.5.  MESSAGE-INTEGRITY](#145--message-integrity)
  - [14.6.  MESSAGE-INTEGRITY-SHA256](#146--message-integrity-sha256)
  - [14.7.  FINGERPRINT](#147--fingerprint)
  - [14.8.  ERROR-CODE](#148--error-code)
  - [14.9.  REALM](#149--realm)
  - [14.10.  NONCE](#1410--nonce)
  - [14.11.  PASSWORD-ALGORITHMS](#1411--password-algorithms)
  - [14.12.  PASSWORD-ALGORITHM](#1412--password-algorithm)
  - [14.13.  UNKNOWN-ATTRIBUTES](#1413--unknown-attributes)
  - [14.14.  SOFTWARE](#1414--software)
  - [14.15.  ALTERNATE-SERVER](#1415--alternate-server)
  - [14.16.  ALTERNATE-DOMAIN](#1416--alternate-domain)
- [15. 注意事项](#15-注意事项)
- [16.  安全考虑](#16--安全考虑)
- [17.  IAB 考虑事项](#17--iab-考虑事项)
- [18.  IANA 考虑事项](#18--iana-考虑事项)
## 1. 引言

本规范定义的协议 **STUN（会话穿越工具，Session Traversal Utilities for NAT）** 是一种用于处理 NAT（网络地址转换）问题的工具。它提供了一种方式，使终端设备能够确定 NAT 为其分配的 IP 地址和端口，这些地址和端口对应于其私有 IP 地址和端口。此外，该协议还提供了一种机制，使终端设备能够维持 NAT 绑定的存活时间。通过一些扩展，该协议还可用于在两个端点之间进行连通性检查 [[RFC8445]()] 或在两个端点之间中继数据包 [[RFC5766]()]。

作为一种工具，本规范定义了一种可扩展的数据包格式，支持多种传输协议，并提供了两种认证方式。

**STUN 旨在用作 NAT 穿越解决方案的一部分，而不是完整的 NAT 穿越解决方案**。这些解决方案被称为 STUN 用法（STUN usages。每种 STUN 用法都描述了如何利用 STUN 实现 NAT 穿越，例如何时发送 STUN 消息、应包含哪些可选属性、使用哪种服务器以及采用何种认证机制。交互式连接建立 (ICE) [[RFC8445]()] 是 STUN 的一种用法。SIP 出站 [[RFC5626]()] 是 STUN 的另一种用法。在某些情况下，用法需要对 STUN 进行扩展。STUN 扩展可以采用新方法、属性或错误响应代码的形式。有关 STUN 用法的更多信息，请参见[第 13 节]()。




## 2. 运行概述  

本节仅作描述性说明。  

```

                               /-----\
                             // STUN  \\
                            |   Server  |
                             \\       //
                               \-----/




                          +--------------+             Public Internet
          ................|     NAT 2    |.......................
                          +--------------+



                          +--------------+             Private NET 2
          ................|     NAT 1    |.......................
                          +--------------+




                              /-----\
                            //  STUN \\
                           |   Client  |
                            \\       //               Private NET 1
                              \-----/
```
**图1：STUN 可能的网络架构**  
在典型 STUN 体系结构（图1）中：  

- **STUN 客户端** 位于私有网络（私网 1）  
- **NAT 设备（NAT 1 和 NAT 2）** 连接不同的私网或公网  
- **STUN 服务器** 位于公网  

STUN 是一种客户端-服务器协议，支持两种事务类型：  

1. **请求/响应事务（request/response transaction）**——客户端发送请求，服务器返回响应。  
2. **指示事务（indication transaction）**——仅包含一个单向指示消息，无需响应。  

所有 STUN 消息都带有一个 96-bit 的事务 ID（transaction ID），用于匹配请求与响应。对于请求/响应事务，此事务 ID 允许客户端将响应与生成它的请求关联起来；对于指示事务，事务 ID 可用作调试辅助。

所有 STUN 消息都以固定标头开头，其中包含方法（method）、类（class）和事务 ID（transaction ID）。本规范仅定义一种方法 Binding，但其他方法预计将在其他文档中定义。类（class）指示这是 request/success response/error response/indication 消息。固定标头后面是零个或多个属性，它们是类型-长度-值扩展，用于传达特定消息的附加信息。

本文档定义了一种名为"绑定"(Binding)的方法。该绑定方法既可用于请求/响应事务，也可用于指示事务。当用于请求/响应事务时，绑定方法可用于确定NAT为STUN客户端分配的特定绑定；当用于请求/响应或指示事务时，该方法还可用于维持这些绑定的活跃状态。

在绑定请求/响应事务中，STUN 客户端向 STUN 服务器发送绑定请求。当绑定请求到达 STUN 服务器时，可能已穿越客户端与服务器之间的一个或多个 NAT（图1示例中存在两个此类 NAT）。当绑定请求报文穿越NAT时，NAT 会修改数据包的源传输地址（即源 IP 地址和源端口）。因此，服务器接收到的请求中的源传输地址将是距服务器最近的那个 NAT 所创建的公共IP地址和端口，这被称为"反射传输地址"。STUN 服务器将该源传输地址复制到 STUN 绑定响应的`XOR-MAPPED-ADDRESS` 属性中，并将绑定响应返回给STUN客户端。当响应包穿回NAT时，NAT会修改IP头中的目标传输地址，但STUN响应体中 `XOR-MAPPED-ADDRESS` 属性内的传输地址将保持不变。通过这种方式，客户端可获知相对于STUN服务器而言，由最外层NAT为其分配的反射传输地址。

在某些应用场景中，STUN 需与其他协议（如[RFC8445]和[RFC5626]）实现多路复用。这些场景中必须存在检测数据包是否为STUN报文的方法。STUN在报文头中提供了三个固定值字段用于此目的。若仍不足够，STUN 报文还可包含 FINGERPRINT 值以进一步区分数据包。

STUN定义了一组可选流程（称为"机制"）供具体应用场景选用。这些机制包括：DNS发现、重定向至备用服务器技术、用于解复用的指纹属性，以及两种认证与消息完整性交换流程。认证机制围绕用户名、密码和消息完整性值展开。本规范定义了两类认证机制：长期凭证机制和短期凭证机制。每种应用场景需明确允许使用的机制。

长期凭证机制中，客户端与服务器共享预先配置的用户名和密码，并执行基于 HTTP [RFC7616]定义但细节有所不同的摘要质询/响应交换。短期凭证机制中，客户端与服务器在STUN交换前通过带外方式交换用户名和密码。例如在 ICE 应用[RFC8445]中，两个端点通过带外信令交换用户名和密码，这些凭证用于对请求和响应进行完整性保护及认证，该过程不使用质询或随机数。


## 3. 术语
本文件使用的关键字 **MUST、MUST NOT、SHALL、SHOULD、MAY** 等，按照 RFC 2119[RFC2119] 进行解释，以指示 STUN 实现的要求级别。  


## 4. 定义  

- **STUN 代理（STUN Agent）**：支持 STUN 协议的实体，包括 STUN 客户端和 STUN 服务器。  
- **STUN 客户端（STUN Client）**：发送 STUN 请求和指示的实体。  
- **STUN 服务器（STUN Server）**：接收 STUN 请求并发送响应的实体。  
- **自反传输地址（Reflexive Transport Address）**：客户端获知的传输地址，用于标识该客户端在 IP 网络上被另一台主机（通常是 STUN 服务器）看到。当客户端与另一台主机之间存在中间 NAT 时，反射传输地址表示在 NAT 的公共端分配给客户端的映射地址。反射传输地址是从 STUN 响应中的映射地址属性（MAPPED-ADDRESS 或 XOR-MAPPED-ADDRESS）获知的。
- **映射地址（Mapped Address）**：即 NAT 为客户端分配的公网 IP 地址和端口，即 `XOR-MAPPED-ADDRESS`。  



## 5. STUN 消息结构 
 

STUN 消息采用二进制编码，使用网络字节序（即最高有效字节优先，通常称为 **大端字节序**）。其传输顺序在 RFC 791 [RFC0791] 的 附录 B 中有详细描述。除非特别说明，数值常量均使用十进制（base 10）。  

**所有 STUN 消息必须以 20 字节的固定头部开头，随后可能包含零个或多个属性（Attributes）**。STUN 头部包含以下字段：
- STUN 消息类型（STUN Message Type）
- 魔法 Cookie（Magic Cookie）
- 事务 ID（Transaction ID）
- 消息长度（Message Length）

```
     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |0 0|     STUN Message Type     |         Message Length        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                         Magic Cookie                          |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                                                               |
    |                     Transaction ID (96 bits)                  |
    |                                                               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图 2：STUN 消息头部格式**  

每个 STUN 消息的 **最高两位必须为 0**。这可以在STUN 复用端口时用于区分 STUN 数据包和其他协议数据包。  

### STUN Message Type
消息类型（STUN Message Type）字段定义了 STUN 消息的类别（request, success response, error response, indication）以及 message method(the primary function)。  

尽管 STUN 具有四种消息类别，但在协议层面上，STUN 仅支持两种事务类型：  

1. 请求/响应事务（request/response transactions），包括请求消息和 响应消息。  
2. 指示事务（indication transactions），**仅包含单个指示消息，不会收到响应**。 

响应类别被划分为错误响应和成功响应，以便快速处理 STUN 消息。 

STUN 消息类型字段进一步分解为以下结构：
```
                        0                 1
                        2  3  4 5 6 7 8 9 0 1 2 3 4 5

                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
                       |M |M |M|M|M|C|M|M|M|C|M|M|M|M|
                       |11|10|9|8|7|1|6|5|4|0|3|2|1|0|
                       +--+--+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图 3：STUN 消息类型（STUN Message Type）字段格式**  

在消息类型字段中，位的排列方式如下：
- M11-M0：12 位，表示 STUN 消息方法。  
- C1、C0：2 位，指示消息类别：
  - `00` = **请求（Request）**
  - `01` = **指示（Indication）**
  - `10` = **成功响应（Success Response）**
  - `11` = **错误响应（Error Response）**  

例如，Binding 请求：
- 类别 `00`（请求），方法 `000000000001`（Binding），编码值：`0x0001`。  

Binding 成功响应：
- 类别 `10`（成功响应），方法 `000000000001`（Binding），编码值：`0x0101`。  

>**注意**：这种编码方式来源于RFC 3489，当时并未考虑指示、成功响应和错误响应需要单独编码。 

### Magic Cookie

**魔法 Cookie 字段必须包含固定值0x2112A442（网络字节序）。**
 
在 RFC 3489 中，该字段曾是事务 ID 的一部分。将魔法 Cookie 置于此位置， **可以帮助服务器检测客户端是否支持本规范新增的属性，并帮助区分 STUN 数据包和其他协议数据包（当 STUN 与其他协议复用端口时）。**  

### Transaction ID

**事务 ID 是一个96 位（12 字节）的唯一标识符，用于唯一标识 STUN 事务， 生成规则如下：**

- 请求/响应事务：
  - 请求（Request）由 STUN 客户端生成事务 ID。  
  - 响应（Response） 由 STUN 服务器回显相同事务 ID。  
- 指示事务：
  - 事务 ID 由 发送指示消息的代理生成。  

事务 ID 主要用于 **将请求与响应关联，同时也可以降低某些攻击的风险**。服务器使用事务 ID 作为唯一键，以区分不同客户端的事务。  

事务 ID 必须在 `0 ... 2^96-1` 的范围内均匀随机选择，并且应采用加密安全的随机数。  

**相同请求的重新发送将重用相同的事务 ID，但客户端必须为新事务选择新的事务 ID**，除非新请求与前一个请求完全相同并从相同的传输地址发送到相同的 IP 地址。成功和错误响应必须携带与其对应请求相同的事务 ID。

当一个代理既作为 STUN 服务器，又作为 STUN 客户端（在同一端口上）时，该代理 **发送的请求的事务 ID与 接收的请求的事务 ID 无任何关系。**  

### Message Length

消息长度 **必须包含消息的字节大小（不包括 20 字节的 STUN 头部）**。  

由于 **所有 STUN 属性都填充为 4 字节的倍数**，因此消息长度字段的最后 2 位始终为 0，这提供了一种额外的方法来区分 STUN 数据包与其他协议数据包。  

 **在 STUN 消息固定头部之后，可能会有零个或多个属性（Attributes）**。  每个 STUN 属性都采用TLV（Type-Length-Value）格式，有关 STUN属性格式的详细信息，请参阅[第 14 节]()。




## 6. 基本协议流程  

本节定义了 STUN 协议的基本流程，包括消息的构造、发送方式以及接收后的处理方式。本节还详细说明了 Binding 方法的处理过程。本规范的其他部分描述了一些可选流程，STUN 用法（usage）可以在特定情况下选择使用。其他文档可能会扩展 STUN，例如 **新增方法、属性或错误响应代码**。


### 6.1. 构造请求或指示消息  

在构造请求（Request）或指示（Indication）消息时，STUN 代理（STUN agent）必须遵循[第 5 节](#5-stun-消息结构)规定的 STUN 头部格式。此外：  

- 消息类别（Message Class）必须是 请求（Request）或 指示（Indication）。  
- 方法（Method）必须是 `Binding` 或其他扩展方法。  

接着，代理需要添加方法或 STUN 用法指定的任何属性。例如，一些 STUN 用法可能要求代理使用认证机制（参见[第 9 节]()）或 FINGERPRINT 属性（参见[第 7 节]()）。  

如果代理发送的是请求（Request），它应该在请求中添加 SOFTWARE 属性。对于指示（Indication），代理可以选择是否包含 SOFTWARE 属性，具体取决于使用的方法。STUN 扩展文档应该讨论 SOFTWARE 属性在新指示消息中的适用性。请注意，包含 SOFTWARE 属性可能会产生安全隐患；有关详细信息，请参阅[第 16.1.2 节]()。

对于不使用认证的 Binding 方法，除非 STUN 用法另有规定，否则不需要任何属性。  

 **所有通过 UDP 或 DTLS-over-UDP [RFC6347] 发送的 STUN 消息应该小于路径 MTU（Path MTU）（如果已知）。** 
 
如果 UDP 路径的 MTU 未知，则消息长度应该小于：  

- IPv4：576 字节（根据 [RFC1122]），扣除 20 字节 IP 头部和 8 字节 UDP 头部 后， STUN 消息最大长度应为548 字节。  
- IPv6：1280 字节（根据 [RFC2460]）。

如果 DTLS-over-UDP 的路径 MTU 未知，则需要调整上一段中描述的规则，以考虑（13 字节）DTLS 记录报头的大小、消息认证码 (MAC) 大小和填充大小。  

STUN 无法处理请求消息小于 MTU 但响应消息超过 MTU 的情况。不过，预计这一限制不会对 STUN 造成影响。  

MTU 限制是应该的，而不是必须的，用于解决使用 STUN 本身探测 MTU 特性的情况 [RFC5780]。另请参阅 [STUN-PMTUD]，了解使用 STUN 向缺乏此类机制的协议添加路径 MTU 发现的框架。除了此应用或类似应用之外，必须遵循 MTU 约束。



### 6.2. 发送请求或指示消息  

代理接下来发送 **请求（Request）** 或 **指示（Indication）**。本规范规定了 **UDP / TCP / TLS-over-TCP / DTLS-over-UDP** 这四种传输方式，未来可能支持其他传输协议。  

STUN 用法必须指定：  
- **使用哪种传输协议**。  
- **代理如何确定接收方的 IP 地址和端口**。  

[第 8 节]() 描述了一种基于 DNS 的方法，可用于确定服务器的 IP 地址和端口，STUN 用法可以选择使用该方法。  

>在任何时候，客户端可以发送多个未完成的 STUN 请求到同一 STUN 服务器（即多个进行中的事务，每个具有不同的事务 ID）。除非另有速率限制（例如 ICE 连接检查或 TCP 传输的 STUN），否则**客户端应该以RTO（重传超时）为间隔发送新事务，并限制自己最多同时拥有 10 个未完成的事务**。  



#### 6.2.1. 通过 UDP 或 DTLS-over-UDP 发送 

当 STUN 运行在 UDP 或 DTLS-over-UDP 之上时，STUN 消息可能会在网络中丢失。 **STUN请求/响应事务的可靠性由客户端自身通过请求重传来保证。**   

- **STUN 指示消息（Indications）不会重传，因此 STUN 通过 UDP 或 DTLS-over-UDP 发送的指示事务是不可靠的**。  

客户端应该按照以下策略重传请求：
- 初始重传时间间隔为 **RTO（Retransmission Timeout），之后每次重传间隔加倍**。  
- RTO 是往返时间（RTT）的估计值，其计算方式参考 [[RFC6298]]()，但有以下两个例外：  
  1. **初始 RTO 应可配置，且默认值不应小于 500 毫秒**（RFC 6298 推荐 3 秒）。  
     - 例外情况：如果使用了其他机制来确定 拥塞控制阈值（例如 ICE 的固定速率流）或在非互联网环境（如局域网）中，RTO 可设置为更低值。  
     - **对于固定线路接入的环境，推荐RTO = 500ms**。  
  2. **RTO 计算不应向上取整到秒级，应保持1 毫秒精度**。  

客户端在事务完成后应该缓存 RTO 值，并在下次向相同服务器（基于 IP 地址）发送请求时作为起始 RTO，该缓存值应在 10 分钟后作废。  

**重传规则**：
- 请求持续重传，直到：
  - 收到响应，或者  
  - 达到最大重传次数（Rc）。默认 Rc = 7（可配置）。  
- **如果发送最后一次请求后的 Rm × RTO 时间内仍未收到响应，客户端应该认为事务已失败**
  - 默认 Rm = 16（可配置）。  
- **收到硬 ICMP 错误（Hard ICMP Error）[RFC1122]时，事务被视为失败** 

例如，假设 RTO = 500ms，请求的发送时间如下：  
```
0ms, 500ms, 1500ms, 3500ms, 7500ms, 15500ms, 31500ms
```
如果客户端在 **39500ms** 内未收到响应，则认为 **超时失败**。  



#### 6.2.2. 通过 TCP 或 TLS-over-TCP 发送  

对于 `TCP` 和 `TLS-over-TCP` 传输方式，客户端需要建立 TCP 连接到服务器。  

在某些 STUN 应用场景中，STUN 是 TCP 连接上唯一运行的协议。这种情况下，无需额外的帧协议（framing protocol）或解复用机制即可直接发送 STUN 消息。

而在其他应用场景或扩展中， **STUN 可能与其他数据协议复用 TCP 连接**。在这种情况下，STUN 必须运行在某种帧协议之上， **该协议由具体的 STUN 用法或扩展规定，以便 STUN 代理正确地提取完整的 STUN 消息和应用层消息**。  

运行于知名端口（well-known port）或通过[第 8 节]() DNS 流程发现的端口的 STUN 服务仅用于纯 STUN 通信 ，不会复用其他数据协议。因此，客户端连接到这些服务器时，不需要额外的帧协议。  

如果使用额外的帧协议，STUN 用法必须指定：
- **客户端如何确定使用该帧协议**
- **客户端应该连接到哪个端口**  

例如，在ICE 连接检查（ICE connectivity check）场景中，该信息是通过客户端和服务器之间的带外（out-of-band）协商确定的。  

STUN 在 TCP 和 TLS-over-TCP 上的可靠性由 TCP 自身保障，STUN 协议层无需重传。然而，对于请求/响应事务，**若客户端在发送 SYN 建立连接后 Ti 秒内未收到响应，则认为事务超时。Ti 应可配置且默认值应为 39.5 秒。此值旨在使 TCP 和 UDP 的默认初始 RTO（重传超时）保持一致。**

此外，若客户端无法建立 TCP 连接，或**在接收响应前连接被重置或失败，则进行中的请求/响应事务视为失败。**


客户端可通过单个 TCP（或 TLS-over-TCP）连接发送多个事务，且无需等待前一个请求的响应即可发送新请求。客户端应保持连接开放，直至满足以下条件：
1. 无更多 STUN 请求或指示需通过该连接发送；
2. 无计划使用通过该连接 STUN 请求获取的资源（如映射地址 `MAPPED-ADDRESS`/`XOR-MAPPED-ADDRESS `或中继地址[RFC5766]）；
3. 若在该端口复用其他应用协议，则相关应用已结束使用；
4. 若将学习到的端口用于远程对端（如某些 TCP NAT 穿越技术要求），则已与该对端建立通信（例如 [RFC6544]）。

**服务器端应该保持 TCP 连接打开，并等待客户端关闭连接，除非服务器检测到连接超时**（例如，客户端断开网络）。  

由于 NAT 设备通常只在 TCP 连接保持打开时保持映射地址有效，因此：
- **服务器不应主动关闭连接**，因为只有客户端知道何时不再需要映射地址。  
- **如果服务器收到请求但尚未发送响应，服务器不得关闭连接**。  
- **服务器不得为了发送响应而主动建立回连（open a connection back to the client）**。  
- 服务器在负载过高时，应遵循最佳的连接管理策略。  

#### 6.2.3. 通过 TLS-over-TCP 或 DTLS-over-UDP 发送


当 STUN 通过 TLS-over-TCP 或 DTLS-over-UDP 运行，必须实现：
- **必须至少支持 `TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256` 和 `TLS_RSA_WITH_AES_128_CBC_SHA`（以兼容此协议的旧版本） 密码套件**，也可以选择支持其他加密套件。请注意，实现 TLS 版本 1.3 [RFC8446] 或后续版本的 STUN 客户端和服务器也需要实现这些规范中的强制性密码套件，并且应在检测到对这些规范的支持时禁用已弃用的密码套件。完美前向保密 (PFS) 密码套件必须优于非 PFS 密码套件。不得使用已知有弱点的密码套件，例如基于（单一）DES 和 RC4 的密码套件。实现必须禁用 TLS 级压缩。这些建议只是 [BCP195] 中建议的一部分，使用 TLS 或 DTLS 的 STUN 使用的实现和部署必须遵循这些建议。
- 客户端在接收 TLS 证书消息时，应验证证书并检查证书标识的站点：
  **若证书无效、被吊销或未标识合法实体，则客户端不得发送 STUN 消息或继续 STUN 事务。** 客户端必须验证服务端身份，具体遵循 [RFC6125] 中定义的识别程序，证书包含 DNS-ID 或 CN-ID 类型的标识符，可选择使用通配符作为最左边的标签，但不能是 SRV-ID 或 URI-ID 类型。

当 STUN 通过 TLS-over-TCP 连接或 DTLS-over-UDP 关联与其他协议多路复用运行时，强制性密码套件和 TLS 处理程序将按照这些协议的定义运行。


### 6.3 接收 STUN 消息

本节规定 STUN 消息的处理流程。此处描述的处理规则适用于本规范定义的 STUN 消息；向后兼容的附加规则详见[第 11 节]()（可选实现，具体应用场景可决定是否采用）。首先执行与消息类别无关的通用处理操作，随后按消息类别进行特定处理（见后续子节）。

当 STUN 代理接收到 STUN 消息时，首先验证消息是否符合第 5 节的规则：  
1. **基础校验**：  
   - 检查消息前 2 位是否为 `0`；
   - 验证 Magic Cookie 字段值正确；
   - 确认消息长度合理；
   - 确认方法值（Method）为支持的方法；
   - 检查消息类别（Class）是否允许用于该方法。  
2. **事务匹配**：  
   - 若消息类别为“成功响应”（Success Response）或“错误响应”（Error Response），验证事务 ID 是否匹配当前进行中的事务。  
3. **扩展校验**：  
   - 若启用了 `FINGERPRINT` 扩展，检查是否存在该属性且值正确。  

若任何校验失败，则静默丢弃消息。当 STUN 与其他协议复用时，错误可能表明该消息并非 STUN 消息，此时代理应尝试将其解析为其他协议。

随后，代理根据应用场景指定的认证机制执行必要检查（参见第 9 节）。

完成认证后，代理检查消息中是否存在：  
- **未知属性**：  
  - 若为可选理解属性（comprehension-optional），必须忽略；  
  - 若为必须理解属性（comprehension-required），处理方式取决于消息类别（见下文）。  
- **已知但非预期属性**：建议忽略。

完成上述步骤后，根据消息类别进行进一步处理。



#### 6.3.1 处理请求

若请求包含一个或多个未知的“必须理解属性”，服务器应返回错误响应：  
- **错误码**：`420（Unknown Attribute）`  
- **附加属性**：包含未知属性的 `UNKNOWN-ATTRIBUTES` 属性。

随后，服务器按方法或应用场景要求执行额外检查。若所有检查通过，生成如下所述的成功响应。

**UDP 重传处理**：  
当通过 UDP 接收请求时，可能是首次请求或重传。服务器对重传的响应需满足以下条件：  
> 若客户端收到重传响应而非原始响应，客户端与服务器的状态应与仅收到重传响应或同时收到两者（客户端使用首个响应）的情况一致。  

**实现方式**：  
1. **状态保留法**（推荐但需权衡）：  
   - 服务器记录过去 **40 秒** 内通过 UDP 接收的事务 ID 及其对应响应。  
   - 适用于需保持状态的场景，但对未认证请求不适用。  
2. **幂等处理法**：  
   - 重新处理请求并生成相同响应，仅适用于幂等请求（即重复请求不会改变系统状态）。  
   - **绑定方法（Binding Method）** 视为幂等操作。  
   - 注意：极少数网络事件可能导致反射传输地址变更，使不同成功响应中的映射地址不同。  
   - **扩展要求**：未存储事务状态的服务器需在扩展中讨论重传影响。


##### 6.3.1.1 构建成功或错误响应

构建响应（成功或错误）时，服务器需遵循第 6 节的规则：  
- **响应方法**：与请求方法相同；  
- **消息类别**：需为“成功响应”（Success Response）或“错误响应”（Error Response）。  

**错误响应的特殊处理**：  
1. **错误码属性**：必须添加 `ERROR-CODE` 属性，包含上述处理流程中指定的错误码。  
2. **原因短语**：非固定内容，但应与错误码匹配。  
3. **附加属性**：  
   - 特定错误需添加额外属性（如错误码 `420（Unknown Attribute）` 必须包含 `UNKNOWN-ATTRIBUTES` 属性）；  
   - 认证错误可能触发附加属性（见第 9 节）；  
   - 扩展可定义新错误码及对应属性。  

**认证处理**：  
- 若请求已通过认证机制验证，响应中应添加相应认证属性（见第 9 节）。  

**通用属性要求**：  
- 按方法或应用场景添加必需属性；  
- 建议在消息中添加 `SOFTWARE` 属性。  

**绑定方法（Binding Method）的特殊规则**：  
- 若无应用场景特殊要求，无需额外检查；  
- 成功响应中必须添加 `XOR-MAPPED-ADDRESS` 属性，其值为请求消息的源传输地址：  
  - **UDP**：请求的源 IP 地址与源 UDP 端口；  
  - **TCP/TLS-over-TCP**：服务器感知的 TCP 连接的源 IP 地址与源 TCP 端口。  



##### 6.3.1.2 发送成功或错误响应

响应的发送方式与接收请求的传输层一致：  
1. **UDP 场景**：  
   - 响应目标地址 = 请求的源 IP 地址与端口；  
   - 响应源地址 = 请求的目标 IP 地址与端口。  
2. **TCP/TLS-over-TCP 场景**：通过同一 TCP 连接返回响应。  


#### 6.3.2 处理指示（Indication）

1. **未知属性检查**：若指示包含未知的“必须理解属性”（comprehension-required），则丢弃并终止处理。  
2. **应用层检查**：按方法或应用场景要求执行额外检查。若通过，处理该指示（无需生成响应）。  

**绑定方法的特殊规则**：  
- 若无特殊要求，仅接收指示即可刷新 NAT 中的“绑定”状态。  
- **UDP 重传机制**：指示无重传机制，发送代理无需处理重传。  


#### 6.3.3 处理成功响应

1. **未知属性检查**：若成功响应含未知的“必须理解属性”，则丢弃响应并视事务失败。  
2. **应用层检查**：按方法或应用场景要求执行额外检查。若通过，处理成功响应。  

**绑定方法的特殊规则**：  
- 检查响应中是否存在 `XOR-MAPPED-ADDRESS` 属性：  
  - **地址族不支持**：应忽略该属性；  
  - **地址族意外但支持**（如 IPv4 请求返回 IPv6 地址）：可选择接受并使用。  



#### 6.3.4 处理错误响应

1. **有效性检查**：  
   - 若错误响应含未知的“必须理解属性”或缺少 `ERROR-CODE` 属性，则视事务失败。  
2. **认证处理**：按身份验证机制（见第 9 节）要求执行处理（可能触发新事务尝试）。  

**默认处理规则**（按错误码分类）：  
- **300-399**：除非使用 `ALTERNATE-SERVER` 扩展（见第 10 节），否则视事务失败；  
- **400-499**：视事务失败。若为 `420（Unknown Attribute）`，响应中应含 `UNKNOWN-ATTRIBUTES` 属性；  
- **500-599**：可重发请求，但需限制重试次数；  
- **其他错误码**：直接视事务失败。  


## 7. FINGERPRINT 机制

本节描述 STUN 的可选扩展机制，用于在传输地址复用时区分 STUN 消息与其他协议数据包。该机制为可选实现，具体应用场景需明确其使用条件。需注意：指纹机制与 **RFC 3489** 不兼容，在需要向后兼容的环境中不可使用。

在某些应用场景中，STUN 消息与其他协议（例如实时传输协议 RTP）的数据包可能会复用同一传输地址，需先分离 STUN 消息以应用第 7 节的流程。虽然 STUN 头部已有三个固定字段（见第 6 节）用于识别，但某些场景下可能仍需额外校验。

**机制实现** ：
1. **发送端**：  
   代理在发送的消息中插入 `FINGERPRINT` 属性（属性格式及位置见第 [15.5 节](#155--fingerprint)）。
2. **接收端**：  
   代理在初步校验后（见第 [7.3 节](#73-接收-stun-消息)处理流程），进一步验证：  
   - 消息是否包含 `FINGERPRINT` 属性；  
   - 属性值是否正确。  
   此机制可有效排除其他协议数据包被误判为 STUN 消息的情况。




## 8. 基于 DNS 的服务器发现

本节描述了一种 STUN 的可选流程，该流程允许客户端利用 DNS 来确定服务器的 IP 地址和端口。每种 STUN 用法都必须说明是否以及何时使用该扩展。为了使用此流程，客户端必须知道服务器的 STUN URI [RFC7064]；此外，应用场景还必须描述客户端如何获取这些信息。不建议将服务器的 STUN URI 硬编码到软件中，以防该 URI 丢失或因法律或其他原因需要更改。

当客户端需定位支持绑定请求/响应事务的公网 STUN 服务器时，应使用 "stun" URI 方案；若需通过 TLS 或 DTLS 会话建立绑定请求/响应事务，则使用 "stuns" URI 方案。"stun" 与"stuns" URI 的语法定义见[RFC7064]第3.1节。具体应用场景可定义额外 URI 方案。

### 8.1. STUN URI Scheme 语义

若 "stun" URI的 \<host> 部分为IP地址，则直接使用该地址联系服务器。含IP地址的"stuns"URI必须被拒绝。未来STUN扩展或应用场景可放宽此限制，但需证明能有效认证STUN服务器并防范中间人攻击。

若URI不含IP地址，则采用[RFC2782]规定的SRV流程将 \<host> 部分的域名解析为传输地址。DNS SRV服务名即<scheme>部分内容，SRV查询中的协议对应STUN运行的传输层协议：UDP对应"udp"，TCP对应"tcp"。

客户端遵循RFC 2782流程确定目标服务器。该标准详细说明了SRV记录集的排序与尝试机制，但仅要求客户端"尝试连接(协议,地址,服务)"而未规定失败处理细则。执行过程中若STUN事务超时未获响应，客户端应按RFC 2782定义的顺序向下一台服务器重试请求（仅适用于需响应的请求/响应事务，指示事务不产生响应故不适用超时重试）。

此外，双栈IPv4/IPv6客户端必须按照[RFC8305]规定，同时查询A与AAAA资源记录，并尝试使用所有获得的IP地址发起请求。

STUN请求默认端口为3478（TCP/UDP通用），基于TLS/DTLS的STUN请求默认端口为5349。若服务器软件支持判别初始报文类型，可在同一端口同时运行DTLS与UDP STUN服务，或TLS与TCP STUN服务。STUN服务器管理员应在SRV记录中为UDP/TCP配置这些标准端口，且DNS记录必须真实反映服务器监听端口。

若未发现SRV记录，客户端按[RFC8305]同时查询域名的A与AAAA记录，获得IP地址列表后：对于普通STUN应用可同时使用UDP/TCP协议访问默认端口；需TLS的应用应连接STUN-over-TLS默认端口；需DTLS的应用应连接STUN-over-DTLS默认端口。


## 9. 身份验证和消息完整性机制

本节定义客户端与服务器在STUN协议中使用的两种认证与消息完整性保障机制，分别为**短期凭证机制和长期凭证机制**。这两种机制属于可选实现，具体应用场景需由各使用方案明确其启用条件及适用范围。客户端和服务器通过判断当前应用场景的类型，即可确定应采用的认证机制（若有）。例如，支持ICE的公网STUN服务器通常无需认证，而执行连通性检查的代理服务器功能模块则需使用短期凭证。[第2节]()已对这两种机制进行了概述。

每种机制均对基础处理流程（[第6节]()定义）进行了扩展，规定了使用该机制所需的额外处理步骤。这些额外处理涉及三个环节：
- 消息构建阶段
- 完成基础校验后的消息接收阶段
- 错误响应详细处理阶段

请注意，代理必须忽略 `MESSAGE-INTEGRITY` 之后的所有属性， `MESSAGE-INTEGRITY-SHA256` 和 `FINGERPRINT` 属性除外。同样，如果不存在 `MESSAGE-INTEGRITY` 属性，代理必须忽略 `MESSAGE-INTEGRITY-SHA256` 属性之后的所有属性， `FINGERPRINT` 属性除外。
### 9.1. 短期凭证机制

短期凭证机制假设在STUN事务发生前，**客户端与服务器已通过其他协议协商获得用户名和密码形式的临时凭证**。该凭证具有时效性，有效期由具体应用场景定义。

例如，在 ICE 应用场景[RFC8445]中，通信双方通过带外信令协商用户名和密码，该凭证在整个媒体会话期间有效。

此类凭证用于为每个请求及多数响应生成消息完整性校验值。该机制不采用长期凭证机制中的挑战-响应模式，而是通过凭证的时效性防止重放攻击。

#### 9.1.1.  HMAC 密钥

对于短期凭证，基于哈希的消息认证代码 (HMAC) 密钥定义如下：
\[
key = OpaqueString(password)
\]

其中 OpaqueString 函数在 [RFC8265] 中定义。使用的编码为 UTF-8 [RFC3629]。


#### 9.1.2. 构建请求或指示

生成请求或指示消息时，代理必须在消息中包含 `USERNAME`、`MESSAGE-INTEGRITY-SHA256`和 `MESSAGE-INTEGRITY` 属性。如果代理通过外部机制知道两个代理都支持哪种消息完整性算法，那么除了 `USERNAME` 之外，便可只包含 `MESSAGE-INTEGRITY` 或 `MESSAGE-INTEGRITY-SHA256` 其中一种。

`MESSAGE-INTEGRITY` 属性的HMAC计算方式遵循[第14.5节]()规定。`MESSAGE-INTEGRITY-SHA256` 属性的HMAC计算方式遵循[第14.6节]()规定。需注意，密码永不随请求或指示传输。

#### 9.1.3. 接收请求或指示

代理完成消息基础处理后，应按以下顺序执行校验：

- 若消息未同时包含 `MESSAGE-INTEGRITY` 或 `MESSAGE-INTEGRITY-SHA256` 其中一种 和 `USERNAME` 属性：
  - 若为请求：服务器必须返回错误代码400（错误请求）的响应拒绝请求。
  - 若为指示：代理必须静默丢弃该指示。

- 若 `USERNAME` 中的用户名在当前服务器无效：
  - 若为请求：服务器必须返回错误代码401（未授权）的响应拒绝请求。
  - 若为指示：代理必须静默丢弃该指示。

- 如果存在 `MESSAGE-INTEGRITY-SHA256` 属性，则使用用户名对应密码按第 14.6 节计算消息完整性值。如果不存在 `MESSAGE-INTEGRITY-SHA256` 则使用 `MESSAGE-INTEGRITY`，按第 14.5 节计算消息完整性值。若结果与 `MESSAGE-INTEGRITY` 属性值不符：
  - 若为请求：服务器必须返回错误代码401（未授权）的响应拒绝请求。
  - 若为指示：代理必须静默丢弃该指示。

所有校验通过后，代理继续处理请求或指示。服务器对包含 `MESSAGE-INTEGRITY-SHA256` 属性的请求生成的任何响应都必须包含 `MESSAGE-INTEGRITY-SHA256` 属性。服务器对仅包含 `MESSAGE-INTEGRITY` 属性的请求生成的任何响应都必须包含 `MESSAGE-INTEGRITY` 属性。这意味着，这些属性中只有一个可以出现在响应中，且不得包含 `USERNAME` 属性。

**校验失败时，服务器禁止在错误响应中包含 `MESSAGE-INTEGRITY-SHA256` 、 `MESSAGE-INTEGRITY `或 `USERNAME` 属性，因无法确定用于计算消息完整性的共享密钥。**

#### 9.1.4. 接收响应

客户端检查响应中的 `MESSAGE-INTEGRITY` 或 `MESSAGE-INTEGRITY-SHA256` 属性。
- 若存在
  - 如果客户端在请求中仅发送了 `MESSAGE-INTEGRITY` 或 `MESSAGE-INTEGRITY-SHA256` 属性之一,则响应中的算法必须匹配；否则，必须丢弃响应。
  - 使用请求所用密码按对应算法计算响应消息完整性值。
    - 若与属性值匹配，则认证通过；
    - 若不符或属性缺失，必须丢弃响应（视为未接收），此时若适用应继续执行重传。

如果请求是通过不可靠传输发送的，则必须丢弃响应，就像从未收到过一样。这意味着，如果适用，将继续重新传输。如果所有收到的响应都被丢弃，那么该层必须发出信号，表明完整性保护已被违反，而不是在结束事务后发出超时信号。

如果请求是通过可靠传输发送的，则必须丢弃响应，并且该层必须立即结束事务并发出信号，表明完整性保护已被违反。

### 9.2.  长期凭证机制

长期凭证机制依赖于一种长期凭证，即客户端和服务器共享的用户名和密码形式的凭证。之所以称为长期凭证，是因为假设该凭证已分配给用户，并且在用户仍为系统订阅者或未更改之前始终有效。这基本上就是传统的“登录”用户名和密码。

由于这些用户名和密码预计在较长时间内都有效，因此通过摘要质询方式提供了重放防护。在这种机制中，客户端最初发送请求时不提供任何凭证或完整性检查。服务器拒绝该请求，并向用户提供一个 realm（用于引导用户或代理选择用户名和密码）以及一个 nonce。nonce 提供了重放保护，它是由服务器选择的 Cookie，并以一种能够指示其有效期限或适用的客户端身份的方式进行编码。客户端重发请求，此时包含自己的用户名和 realm，并回显服务器提供的 nonce；同时还包含一个消息完整性值，该值为整个请求（包括 nonce）的 HMAC。服务器验证 nonce 并检查消息完整性。如果两者匹配，则请求通过认证；如果 nonce 不再有效，则被视为“陈旧的”，服务器拒绝该请求，并提供一个新的 nonce。

在后续向同一服务器发送的请求中，客户端会重用之前使用的 nonce、用户名、realm 和密码。这样，直到服务器使 nonce 失效之前，后续请求不会被拒绝；一旦 nonce 失效，拒绝响应会向客户端提供一个新的 nonce。

注意，长期凭证机制不能用于保护指示（indications），因为指示无法进行质询。使用指示的用法必须要么采用短期凭证，要么对其省略身份验证和消息完整性保护。

## 10. ALTERNATE-SERVER 机制

本节介绍了 STUN 中的一种机制，该机制允许服务器将客户端重定向到另一台服务器。该扩展是可选的，每种具体用法都必须定义是否以及何时使用该扩展。


## 11. 与 RFC 3489 向后兼容性

本节定义了一套程序，使得新旧版本之间能够在一定程度上实现兼容。这一机制是可选的，仅在新客户端需要与旧服务器互联，或旧客户端需要与新服务器互联的情况下使用。具体用法必须明确定义在何时以及如何使用该机制。

[第 19 节]()列出了本规范与 RFC 3489 之间的所有变化，但并非所有差异都十分关键，因为“经典 STUN”仅在少数特定场景中使用。对于本扩展来说，主要的变化包括：
- 在 RFC 3489 中，仅支持 UDP 传输；
- 原本现在称为 `magic cookie` 的字段当时是交易 ID 字段的一部分，且交易 ID 长度为 128 位；
- 不存在 `XOR-MAPPED-ADDRESS` 属性，Binding 方法使用的是 `MAPPED-ADDRESS` 属性；
> RFC 3489 中要求必须理解的三个属性—`—RESPONSE-ADDRESS`、`CHANGE-REQUEST` 和 `CHANGED-ADDRESS`——已从本规范中移除，其中 `CHANGE-REQUEST` 和 `CHANGED-ADDRESS` 现已成为 NAT 行为发现用法的一部分，而另一个属性则被废弃。

### 11.1 客户端处理的更改

希望与 RFC 3489 服务器互操作的客户端，应该发送一个使用 Binding 方法、没有包含任何属性且采用 UDP 作为传输协议的请求消息。如果请求成功，服务器返回的成功响应中将包含 MAPPED-ADDRESS 属性而不是 XOR-MAPPED-ADDRESS 属性。试图与旧服务器互操作的客户端必须能够处理这两种属性。此外，客户端必须忽略响应中可能出现的任何预留的、要求必须理解的属性。在 RFC 3489 中预留的属性（例如 0x0002、0x0004、0x0005 和 0x000B）可能会出现在符合 RFC 3489 规范的服务器返回的 Binding 响应中。除此之外，响应的处理过程与前面描述的程序完全一致。

### 11.2 服务器处理的更改

STUN 服务器可以通过检查 Binding 请求消息中 magic cookie 字段的值，来判断该请求是否来自 RFC 3489 客户端。如果检测到请求来自 RFC 3489 客户端，服务器应将请求中所看到的 magic cookie 字段的值复制到响应消息中的相应字段，并在响应中插入 MAPPED-ADDRESS 属性，而不是 XOR-MAPPED-ADDRESS 属性。

在极少数情况下，客户端可能会包含 RESPONSE-ADDRESS 或 CHANGE-REQUEST 属性，此时服务器会将这些属性视为未知的、必须理解的属性，并以错误响应回复。由于使用这些属性的机制已不再支持，因此这种行为是可以接受的。

由于 RFC 3489 版本的 STUN 不包含 magic cookie 和 FINGERPRINT 属性，这些属性能在多协议复用时大大提高正确识别 STUN 消息的概率，因此要求向后兼容 RFC 3489 的实现，在复用其他协议的场景中不应使用 RFC 3489 模式。不过，这通常不会成为问题，因为在 RFC 3489 中并没有支持这种复用



## 12. 基本服务器行为

本节定义独立 STUN 服务器的基本功能：通过处理 Binding 请求为客户端提供服务器反射传输地址。

#### 核心要求
1. **方法支持**：必须支持 Binding 方法。  
2. **认证机制**：不建议使用短期或长期凭证（认证开销高于处理请求本身）。  
3. **传输协议**：必须支持 UDP 和 TCP，可选支持 TLS（但 TLS 在基础模式中安全性收益有限）。  
4. **兼容性**：应支持 RFC 3489 客户端（见第 12 章），且不得强制要求指纹机制（以免破坏兼容性）。  

#### 部署建议
- **DNS 配置**：建议按第 9 节配置 SRV 记录，便于客户端发现服务器。  
- **功能定位**：独立 STUN 服务器本身不解决 NAT 穿透问题，但可通过 STUN 应用场景（如 ICE）作为解决方案的一部分。  



## 13.  STUN 用法

STUN 本身并不是 NAT 穿越问题的解决方案，而是定义了一种可在更大解决方案中使用的工具。STUN 用法 这一术语用于指代任何将 STUN 作为组成部分的解决方案。

未来可能还会定义其他 STUN 用法。

## 14. STUN 属性

STUN 消息头部之后可包含零个或多个属性。每个属性采用 TLV（类型-长度-值）编码格式，即包含一个 16 位的类型、16 位的长度和对应的变长值。所有属性必须按 32 位对齐，且字段均以大端字节序传输。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Type                  |            Length             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Value (variable)                ....
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图4：STUN 属性的格式**

**长度字段**表示值的实际字节数（不含填充）。若值长度非 4 字节的倍数，需在尾部填充 1-3 字节的任意值以满足对齐要求，填充内容可被忽略。

在 STUN 消息中，任何属性类型可以出现多次。除非另有说明，属性的出现顺序是有意义的：**接收方只需要处理第一次出现的该属性，其余重复出现的属性可以被忽略**。

为了便于将来对本规范的修订时根据需要添加新属性，属性(Type)空间被划分为两个范围。
- 0x0000 - 0x7FFF: “必须理解”属性，这意味着 STUN 代理如果不理解该属性，将无法成功处理消息；
- 0x8000 - 0xFFFF: 可选理解”属性，这意味着如果 STUN 代理不理解这些属性，可以将其忽略。

STUN 属性类型的集合由 IANA 进行维护。本规范中定义的初始属性集合见于[第 18.3 节]()。

本节余下部分描述了本规范中定义的各个属性的格式。

### 14.1. MAPPED-ADDRESS

MAPPED-ADDRESS 属性表示客户端的反射传输地址。它由一个 8 位的地址族和一个 16 位的端口组成，后跟一个固定长度的值表示 IP 地址。如果地址族为 IPv4，则地址必须为 32 位；如果地址族为 IPv6，则地址必须为 128 位。所有字段均须采用网络字节序。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |0 0 0 0 0 0 0 0|    Family     |           Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      |                 Address (32 bits or 128 bits)                 |
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图5：MAPPED-ADDRESS 属性的格式**

地址族（Family）可以取以下值：
- `0x01`：IPv4
- `0x02`：IPv6
  
MAPPED-ADDRESS 的**前 8 位必须设置为 0**，并且接收方必须忽略这些位。这些位的存在是为了使参数在自然的 32 位边界上对齐。

该属性仅由服务器使用，以实现与 RFC 3489 [[RFC3489]]() 客户端的向后兼容


### 14.2. XOR-MAPPED-ADDRESS

XOR-MAPPED-ADDRESS 属性功能与 MAPPED-ADDRESS 相同，但其反射传输地址通过 XOR 运算进行了混淆。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |x x x x x x x x|    Family     |         X-Port                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                X-Address (Variable)
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图6：XOR-MAPPED-ADDRESS 属性的格式**
其中，Family 表示 IP 地址族，其编码方式与 MAPPED-ADDRESS 中的 Family 相同。
编码规则：  
- X-Port：将主机的端口号与 Magic Cookie 的高 16 位异或后转为网络字节序。  
- X-Address：  
  - IPv4：取映射的 IP 地址（以主机字节序表示）与魔术字异或后转为网络字节序。  
  - IPv6：取映射的 IP 地址（以主机字节序表示）与魔术字及 96 位事务 ID 拼接值异或后转为网络字节序。  
 
对于属性值的前 8 位的编码和处理规则、处理属性多次出现的规则以及地址族的处理规则，与 MAPPED-ADDRESS 完全相同。

>XOR-MAPPED-ADDRESS 与 MAPPED-ADDRESS 仅在传输地址的编码方式上有所不同。前者通过将传输地址与 magic cookie 进行异或运算来编码，而后者则直接以二进制方式编码。RFC 3489 最初仅规定了 MAPPED-ADDRESS，但实际部署经验发现，一些 NAT 会重写包含 NAT 公网 IP 地址的 32 位二进制负载（如 STUN 的 MAPPED-ADDRESS 属性），这种出于提供通用 ALG 功能的善意但错误的尝试，会干扰 STUN 的正常运行，并导致 STUN 的消息完整性检查失败。


### 14.3.  USERNAME

USERNAME 属性用于消息完整性校验，标识消息完整性检查中使用的用户名与密码组合。其值为变长字段，要求：
- Value 采用 UTF-8 编码（RFC 3629），长度小于 513 字节；
- **必须经过 OpaqueString [RFC8265] 规范化处理**。
- 兼容的实现必须 能够解析 763 个或更少八位字节的 UTF-8 编码序列， 以与 [RFC5389] 兼容。

### 14.4.  USERHASH
当支持用户名匿名时，`USERHASH` 属性用于替代 `USERNAME` 属性。`USERHASH` 的值固定为 32 个字节。在进行哈希处理之前，必须使用 OpaqueString [RFC8265] 处理 `username`
，使用 OpaqueString [RFC8265] 处理 `realm` 。

以下是客户端将执行的哈希处理用户名的操作：
\[
userhash = SHA-256(OpaqueString(username) ":" OpaqueString(realm))
\]

### 14.5.  MESSAGE-INTEGRITY

`MESSAGE-INTEGRITY` 属性包含 STUN 消息的 `HMAC-SHA1`（[RFC 2104]()）校验值，长度固定为 20 字节。该校验值基于整个 STUN 消息计算（含头部及 `MESSAGE-INTEGRITY` 之前的所有属性）。除位于 `MESSAGE-INTEGRITY` 之后的 `FINGERPRINT` 属性外，代理**必须忽略所有跟在 `MESSAGE-INTEGRITY` 属性之后的其他属性**。

HMAC 所用密钥取决于所使用的是长期凭证还是短期凭证。

**对于长期凭证，密钥为 16 字节，其计算方法为：**
\[ key = MD5(username ":" realm ":" SASLprep(password)) \]

也就是说，该 16 字节密钥是通过将下列五个字段依次串联后计算 MD5 哈希得到的：
  1. 从 USERNAME 属性中获得的用户名（已去除引号和尾随的空字符，此时已经经过 SASLprep 规范化处理）
  2. 一个冒号
  3. 去除引号和尾随空字符的 realm（域）
  4. 一个冒号
  5. 经过 SASLprep 处理且去除尾随空字符的密码。
  例如，如果用户名为 "user"、realm 为 "realm"、密码为 "pass"，则 16 字节的 HMAC 密钥就是对字符串 "user:realm:pass" 进行 MD5 哈希后得到的结果，即 0x8493fbc53ba582fb4c044c456bdc40eb。

**对于短期凭证，则有：**

\[ key = SASLprep(password) \]

>其中，MD5 定义见 RFC 1321 [RFC1321]，而 SASLprep() 定义见 RFC 4013 [RFC4013]。

采用长期凭证时密钥的结构有助于在同时使用 SIP 的系统中进行部署。通常，采用 SIP 摘要认证机制的 SIP 系统不会在数据库中存储实际密码，而是存储一个称为 H(A1) 的值，该值等同于上述定义的密钥。

根据上述规则，用于构造 MESSAGE-INTEGRITY 的哈希值会包括 STUN 消息头中的长度字段。
- 在执行哈希计算之前，必须先将 MESSAGE-INTEGRITY 属性插入到 STUN 消息中（其内容可先填入一个占位值）。
- 接着，长度字段必须设置为表示从消息起始到（并包含）MESSAGE-INTEGRITY 属性本身部分的长度，但不包括其后任何属性。
- 计算完成后，再将正确的 MESSAGE-INTEGRITY 值填入该属性，并将 STUN 消息头中的长度字段更新为整个消息的实际长度。
- 同样，在验证 MESSAGE-INTEGRITY 时，应先将长度字段调整为指向 MESSAGE-INTEGRITY 属性末尾，再计算 HMAC。当 MESSAGE-INTEGRITY 后面还存在诸如 FINGERPRINT 等属性时，这种调整是必要的。

### 14.6.  MESSAGE-INTEGRITY-SHA256


### 14.7.  FINGERPRINT

FINGERPRINT 属性可以出现在所有 STUN 消息中。该属性的值通过以下方式计算得出：

- 对 STUN 消息（直至但不包括 FINGERPRINT 属性本身）计算 CRC-32，然后将结果与 32 位值 0x5354554e（ASCII "STUN"） 进行异或运算（异或操作有助于在应用数据包中也使用 CRC-32 的情况下区分开来）。
> 该 32 位 CRC 依据 ITU V.42 [ITU.V42.2002] 定义，其生成多项式为  
\[x^{32} + x^{26} + x^{23} + x^{22} + x^{16} + x^{12} + x^{11} + x^{10} + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\]

当 FINGERPRINT 属性存在时，**必须将其作为消息中的最后一个属性**，因此它将出现在 MESSAGE-INTEGRITY 属性之后。

FINGERPRINT 属性有助于将 STUN 数据包与其他协议的数据包区分开来（参见第8节）。

与 MESSAGE-INTEGRITY 类似，FINGERPRINT 属性所使用的 CRC 计算也覆盖了 STUN 消息头中的长度字段。**因此，在计算 CRC 之前，该长度值必须正确，并且应将 CRC 属性视为消息长度的一部分。在使用 FINGERPRINT 属性时，应先将其以占位值插入消息中，然后计算 CRC，最后更新该属性的值。** 如果消息中同时存在 MESSAGE-INTEGRITY 属性，则在计算 CRC 前，MESSAGE-INTEGRITY 属性必须已包含正确的消息完整性值，因为 CRC 的计算也涵盖了该属性的内容。

### 14.8.  ERROR-CODE

ERROR-CODE 属性用于错误响应消息。它包含一个数值错误代码（范围为 300 至 699）以及一个以 UTF-8 [RFC3629] 编码的文本原因短语，其代码分配和语义与 SIP [RFC3261] 及 HTTP [RFC2616] 保持一致。该原因短语供用户查看，可以是与错误代码相适应的任意内容。对于各错误代码，推荐的原因短语已包含在 IANA 的错误代码注册表中。**原因短语必须为 UTF-8 [RFC3629] 编码的序列，字符数少于 128 个（其字节数最多可达 763 字节）**。

    
```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Reserved, should be 0         |Class|     Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Reason Phrase (variable)                                ..
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图7：ERROR-CODE 属性**

为便于处理，错误代码的类别（即错误代码的百位数字）被单独编码，与代码的其他部分分开，如图7所示。

- 保留位（Reserved）应为 0，用于在 32 位边界上的对齐；接收方必须忽略这些位。
- Class 表示错误代码的百位数字，其值**必须**介于 3 到 6 之间
- Number 表示错误代码除以 100 后的余数，其值**必须**介于 0 到 99 之间
- Reason Phrase，表示原因，UTF-8 编码，长度小于 128 字符（763 字节）

定义了以下错误代码及其推荐的原因短语：

- 300  Try Alternate：客户端应就此请求联系另一台服务器。**仅当请求中包含 USERNAME 属性和有效的 MESSAGE-INTEGRITY 属性时，才发送该错误响应**；否则不得发送，建议使用错误代码 400（Bad Request）。该错误响应必须由 MESSAGE-INTEGRITY 属性保护，接收方在将自己重定向至另一服务器前，必须验证该响应的 MESSAGE-INTEGRITY。

>注意：如果未能为 300 响应生成并验证消息完整性，将可能使路径上的攻击者伪造 300 响应，从而导致后续 STUN 消息被错误地发送给受害者。

- 400  Bad Request：请求格式错误。客户端不应在未对先前请求做出修改的情况下重试。服务器可能无法为此错误生成有效的 MESSAGE-INTEGRITY，因此客户端不得期望响应中包含有效的 MESSAGE-INTEGRITY 属性。

- 401  Unauthorized：请求中未包含正确的凭证以继续。客户端应使用正确凭证重试该请求。

- 420  Unknown Attribute：服务器收到的 STUN 数据包中包含一个要求必须理解但其内容无法识别的属性。服务器**必须**将该未知属性放入错误响应中的 UNKNOWN-ATTRIBUTE 属性中。

- 438  Stale Nonce：客户端使用的 NONCE 已不再有效。客户端应使用响应中提供的 NONCE 重试该请求。

- 500  Server Error：服务器遭遇临时错误。客户端应重试该请求。


### 14.9.  REALM

REALM 属性可以出现在请求和响应中。它包含的文本须符合 RFC 3261 [RFC3261] 中描述的 "realm-value" 语法，但不包括双引号及其周围的空白。也就是说，它是一个未加引号的 realm-value（因此是 `qdtext` 或 `quoted-pair` 的序列）。要求：
- Value必须是一个 UTF-8 [RFC3629] 编码的序列，字符数少于 128 个（可达 763 字节
- **必须经过 SASLprep [RFC4013] 处理**。

请求中出现 REALM 属性表示正在使用长期凭证进行身份验证；在某些错误响应中出现则表示服务器希望客户端使用长期凭证进行身份验证。

### 14.10.  NONCE

NONCE 属性可以出现在请求和响应中。它包含一系列 `qdtext` 或 `quoted-pair`（定义见 RFC 3261 [RFC3261]）。注意，这意味着 NONCE 属性中不会包含实际的引号字符。有关服务器中 nonce 值选择的指导，请参见 RFC 2617 [RFC2617] 第 4.3 节。

- **格式要求**：必须少于 128 个字符（可达 763 字节）。

### 14.11.  PASSWORD-ALGORITHMS

### 14.12.  PASSWORD-ALGORITHM

### 14.13.  UNKNOWN-ATTRIBUTES

UNKNOWN-ATTRIBUTES 属性仅出现在错误码为 `420（Unknown Attribute）` 的错误响应中，用于列出服务器无法识别的必须理解属性类型。

该属性包含一系列 16 位值，每个值代表一个服务器无法理解的属性类型。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Attribute 1 Type           |     Attribute 2 Type        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Attribute 3 Type           |     Attribute 4 Type    ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
**图8：UNKNOWN-ATTRIBUTES 属性的格式**

>注意：在 [RFC3489] 中，此字段通过复制最后一个属性进行填充至 32 位；而在本版本的规范中，则采用了属性的正常填充规则。

### 14.14.  SOFTWARE

SOFTWARE 属性包含发送消息的代理所使用软件的文本描述。该属性既由客户端使用，也由服务器使用。其值**应该包含制造商信息和版本号**。该属性对协议操作没有影响，仅作为诊断和调试的工具。SOFTWARE 的值为可变长度数据，
- **格式要求**：必须为 UTF-8 [RFC3629] 编码的序列，字符数少于 128 个（可达 763 字节）。

### 14.15.  ALTERNATE-SERVER

Alternate-Server 表示一个备用的传输地址，用以标识 STUN 客户端应尝试连接的另一台 STUN 服务器。

该属性的编码方式与 MAPPED-ADDRESS 相同，因此通过 IP 地址引用单个服务器。请求源 IP 地址的地址族**必须**与此备用服务器所使用的 IP 地址族相同。

### 14.16.  ALTERNATE-DOMAIN

## 15. 注意事项
STUN 可以与任播地址一起使用，但只能与 UDP 一起使用，并且只能在未使用身份验证的 STUN 用途中使用。

## 16.  安全考虑

## 17.  IAB 考虑事项

AB 已经研究了“单边自地址修正（Unilateral Self-Address Fixing, UNSAF）”问题，即客户端通过协作式协议反射机制（见 RFC3424 [RFC3424]）尝试确定其位于 NAT 另一侧其他域中的地址的通用过程。如果一个代理位于 NAT 内部，而另一个代理位于 NAT 的公网侧，则 STUN 可利用 Binding 请求/响应事务来实现这一功能。

IAB 要求为此目的开发的协议必须记录一系列特定的考虑事项。由于某些 STUN 用法（例如 ICE）提供 UNSAF 功能，而其他用法（例如 SIP Outbound）则不提供，因此这些考虑事项的答案需要由各自的用法自行解决。

## 18.  IANA 考虑事项

